import NetInfo, { NetInfoState } from '@react-native-community/netinfo';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { firebaseService, FirebaseService } from './FirebaseService';
import { getAuth } from 'firebase/auth';

// UUID generation utility for offline scenarios
function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

interface SyncQueueItem {
  id: string;
  action: 'create' | 'update' | 'delete' | 'updateBalance';
  collection: 'products' | 'staff-users' | 'assignments' | 'players' | 'reports';
  data: any;
  timestamp: number;
  retryCount: number;
  // Batch grouping for related operations
  batchId?: string;
  batchLabel?: string; // User-friendly label like "Assignment Sale"
}

// Unified Operation Interface - Single Source of Truth for All Writes
interface Operation {
  id: string;
  type: 'create' | 'update' | 'delete' | 'updateBalance' | 'createAssignmentTransaction';
  collection: 'products' | 'staff-users' | 'assignments' | 'players' | 'reports';
  entityId?: string;
  data: any;
  metadata: {
    deviceId: string;
    timestamp: number | string; // Allow both number (ms) and string (ISO) for compatibility
    version: number;
    vectorClock: Record<string, number>;
    userId?: string;
    source: 'local' | 'server' | 'sync';
  };
}

export class HybridSyncService {
  private syncQueue: SyncQueueItem[] = [];
  private isOnline: boolean = true;
  private isSyncing: boolean = false;
  private syncQueueKey = 'sync_queue';
  private maxRetries = 3;
  private syncInterval: any = null;
  private deviceId: string;
  private vectorClock: Map<string, number> = new Map();
  private processedIds: Set<string> = new Set(); // Idempotency tracking
  private deadLetterQueue: SyncQueueItem[] = [];
  private batchSize = 10; // Process items in batches for better performance

  constructor() {
    // Initialize device-specific vector clock
    this.deviceId = this.generateDeviceId();
    
    this.initializeNetworkListener();
    this.loadSyncQueue();
    this.initializeVectorClock(); // Async initialization
    this.startBackgroundSync();
  }

  // ============================================
  // SINGLE SOURCE OF TRUTH - UNIFIED WRITE PATH
  // ============================================

  /**
   * applyOp - The ONLY way to write data in the system
   * 
   * ALL writes must go through this function to ensure:
   * 1. Local cache is updated first (truth always local)
   * 2. Consistent version bumping and timestamps
   * 3. Proper conflict resolution rules
   * 4. Outbox queue management
   * 5. Server hydration happens after local success
   */
  public async applyOp(operation: Operation): Promise<void> {
    console.log('üìù applyOp - Single write path:', {
      type: operation.type,
      collection: operation.collection,
      entityId: operation.entityId,
      source: operation.metadata.source,
      online: this.isOnline,
      timestamp: operation.metadata.timestamp,
      timestampType: typeof operation.metadata.timestamp
    });

    // Special logging for player create operations
    if (operation.collection === 'players' && operation.type === 'create') {
      console.log('üéØ APPLY OP - Player creation detected:', {
        playerId: operation.entityId,
        playerName: operation.data?.name || `${operation.data?.firstName} ${operation.data?.lastName}`,
        isOnline: this.isOnline,
        willSync: this.isOnline && operation.metadata.source === 'local',
        operationId: operation.id
      });
    }

    try {
      // Validate operation structure
      if (!operation.metadata || operation.metadata.timestamp === undefined) {
        throw new Error('Invalid operation: missing metadata or timestamp');
      }

      // Step 1: ALWAYS update local cache first (truth is local)
      await this.applyOpToLocalCache(operation);
      
      // Step 2: Add to outbox for server sync (if not from server)
      if (operation.metadata.source !== 'server') {
        await this.addOpToOutbox(operation);
      }
      
      // Step 3: Attempt immediate server sync if online (best effort)
      if (this.isOnline && operation.metadata.source === 'local') {
        try {
          await this.syncOpToServer(operation);
          // If immediate sync succeeds, remove from outbox to prevent duplicate
          await this.removeOpFromOutbox(operation.id);
          console.log('‚úÖ Operation synced immediately and removed from outbox:', operation.id);
        } catch (error) {
          console.warn('‚ö†Ô∏è Immediate server sync failed, will retry via outbox:', error);
          // Don't throw - local cache is already updated, outbox will handle retry
        }
      }
      
      console.log('‚úÖ applyOp completed successfully');
      
    } catch (error) {
      console.error('‚ùå applyOp failed:', error);
      console.error('‚ùå Operation details:', {
        type: operation.type,
        collection: operation.collection,
        entityId: operation.entityId,
        metadata: operation.metadata
      });
      throw error;
    }
  }

  /**
   * Apply operation to local cache with conflict resolution
   */
  private async applyOpToLocalCache(operation: Operation): Promise<void> {
    const { collection, type, entityId, data, metadata } = operation;
    
    // Validate and normalize timestamp to ISO string for storage
    let normalizedTimestamp: string;
    try {
      if (typeof metadata.timestamp === 'string') {
        // If it's already an ISO string, use it directly
        normalizedTimestamp = metadata.timestamp;
        // Validate it's a valid date
        const testDate = new Date(normalizedTimestamp);
        if (isNaN(testDate.getTime())) {
          throw new Error(`Invalid date string: ${normalizedTimestamp}`);
        }
      } else if (typeof metadata.timestamp === 'number') {
        // If it's a number (milliseconds), convert to ISO string
        const date = new Date(metadata.timestamp);
        if (isNaN(date.getTime())) {
          throw new Error(`Invalid timestamp number: ${metadata.timestamp}`);
        }
        normalizedTimestamp = date.toISOString();
      } else {
        throw new Error(`Invalid timestamp type: ${typeof metadata.timestamp}`);
      }
    } catch (error) {
      console.error('‚ùå Invalid timestamp in operation:', metadata.timestamp, error);
      // Fallback to current timestamp
      normalizedTimestamp = new Date().toISOString();
      console.warn('‚ö†Ô∏è Using current timestamp as fallback:', normalizedTimestamp);
    }

    console.log('üíæ Applying to local cache:', {
      collection,
      type,
      entityId,
      timestamp: normalizedTimestamp,
      originalTimestamp: metadata.timestamp
    });

    // Get current local data
    const currentData = await this.getLocalData(collection);
    let updatedData: any[];

    switch (type) {
      case 'create':
        updatedData = await this.applyCreateOp(currentData, data, metadata, normalizedTimestamp);
        break;
        
      case 'update':
        updatedData = await this.applyUpdateOp(currentData, entityId!, data, metadata, normalizedTimestamp);
        break;
        
      case 'updateBalance':
        updatedData = await this.applyBalanceUpdateOp(currentData, entityId!, data, metadata, normalizedTimestamp);
        break;
        
      case 'createAssignmentTransaction':
        // This is a compound operation that affects multiple collections
        await this.applyAssignmentTransactionOp(data, metadata, normalizedTimestamp);
        return; // Early return since we handle multiple collections internally
        
      case 'delete':
        updatedData = await this.applyDeleteOp(currentData, entityId!, metadata);
        break;
        
      default:
        throw new Error(`Unknown operation type: ${type}`);
    }

    // Atomically save updated data
    await this.saveLocalData(collection, updatedData);
    
    console.log('‚úÖ Local cache updated successfully');
  }

  /**
   * Apply create operation to local data
   */
  private async applyCreateOp(currentData: any[], entityData: any, metadata: Operation['metadata'], normalizedTimestamp: string): Promise<any[]> {
    // Use the already normalized timestamp
    
    const newEntity = {
      ...entityData,
      id: entityData.id || generateUUID(),
      createdAt: normalizedTimestamp,
      updatedAt: normalizedTimestamp,
      version: this.createVersionVector()
    };
    
    // Check if entity already exists (idempotency)
    const existingIndex = currentData.findIndex(item => item.id === newEntity.id);
    if (existingIndex !== -1) {
      console.log('‚è≠Ô∏è Create operation idempotent - entity already exists:', newEntity.id);
      return currentData; // No change needed
    }
    
    return [...currentData, newEntity];
  }

  /**
   * Apply update operation with conflict resolution
   */
  private async applyUpdateOp(currentData: any[], entityId: string, updates: any, metadata: Operation['metadata'], normalizedTimestamp: string): Promise<any[]> {
    const entityIndex = currentData.findIndex(item => item.id === entityId);
    
    if (entityIndex === -1) {
      console.warn('‚ö†Ô∏è Update operation - entity not found:', entityId);
      return currentData; // No change if entity doesn't exist
    }
    
    const currentEntity = currentData[entityIndex];
    const updatedData = [...currentData];
    
    // Apply conflict resolution rules
    const resolvedEntity = await this.resolveConflicts(currentEntity, updates, metadata);
    
    updatedData[entityIndex] = {
      ...resolvedEntity,
      updatedAt: normalizedTimestamp,
      version: this.createVersionVector()
    };
    
    console.log('üîÑ Entity updated with conflict resolution:', entityId);
    return updatedData;
  }

  /**
   * Apply balance update operation (specialized for player balances)
   */
  private async applyBalanceUpdateOp(currentData: any[], playerId: string, balanceData: any, metadata: Operation['metadata'], normalizedTimestamp: string): Promise<any[]> {
    const playerIndex = currentData.findIndex(item => item.id === playerId);
    
    if (playerIndex === -1) {
      console.warn('‚ö†Ô∏è Balance update - player not found:', playerId);
      return currentData;
    }
    
    const player = { ...currentData[playerIndex] };
    const { amount, isDebit } = balanceData;
    
    // Apply balance changes with conflict resolution
    const currentBalance = player.balance || 0;
    const newBalance = isDebit ? 
      currentBalance + amount : 
      Math.max(0, currentBalance - amount);
    
    // Update tracking fields
    player.balance = newBalance;
    if (isDebit) {
      player.totalSpent = (player.totalSpent || 0) + amount;
      player.totalPurchases = (player.totalPurchases || 0) + 1;
    }
    
    // Set metadata with normalized timestamp
    player.updatedAt = normalizedTimestamp;
    player.version = this.createVersionVector();
    
    const updatedData = [...currentData];
    updatedData[playerIndex] = player;
    
    console.log('üí∞ Balance updated via applyOp:', {
      playerId,
      newBalance,
      amount,
      isDebit
    });
    
    return updatedData;
  }

  /**
   * Apply delete operation
   */
  private async applyDeleteOp(currentData: any[], entityId: string, metadata: Operation['metadata']): Promise<any[]> {
    const filteredData = currentData.filter(item => item.id !== entityId);
    
    if (filteredData.length === currentData.length) {
      console.log('‚è≠Ô∏è Delete operation idempotent - entity already removed:', entityId);
    } else {
      console.log('üóëÔ∏è Entity deleted via applyOp:', entityId);
    }
    
    return filteredData;
  }

  /**
   * Apply compound assignment transaction - affects multiple collections atomically
   */
  private async applyAssignmentTransactionOp(data: any, metadata: Operation['metadata'], normalizedTimestamp: string): Promise<void> {
    console.log('üí∞ Applying assignment transaction to local cache:', {
      assignment: data.id,
      product: data.productId,
      player: data.playerId,
      quantity: data.quantity,
      total: data.total
    });

    try {
      // 1. Create the assignment
      const assignmentsData = await this.getLocalData('assignments');
      const newAssignment = {
        ...data,
        createdAt: normalizedTimestamp,
        updatedAt: normalizedTimestamp,
        version: this.createVersionVector()
      };

      // Check if assignment already exists (idempotency)
      const existingAssignmentIndex = assignmentsData.findIndex(item => item.id === newAssignment.id);
      if (existingAssignmentIndex !== -1) {
        console.log('‚è≠Ô∏è Assignment transaction idempotent - assignment already exists:', newAssignment.id);
        return; // Early return - transaction already applied
      }

      const updatedAssignments = [...assignmentsData, newAssignment];

      // 2. Reduce product stock
      const productsData = await this.getLocalData('products');
      const productIndex = productsData.findIndex(p => p.id === data.productId);
      if (productIndex === -1) {
        throw new Error(`Product not found for assignment transaction: ${data.productId}`);
      }

      const product = productsData[productIndex];
      if (product.stock < data.quantity) {
        throw new Error(`Insufficient stock for product ${product.name}. Available: ${product.stock}, Required: ${data.quantity}`);
      }

      const updatedProducts = [...productsData];
      updatedProducts[productIndex] = {
        ...product,
        stock: product.stock - data.quantity,
        updatedAt: normalizedTimestamp,
        version: this.createVersionVector()
      };

      // 3. Update player balance and stats
      const playersData = await this.getLocalData('players');
      const playerIndex = playersData.findIndex(p => p.id === data.playerId);
      if (playerIndex === -1) {
        throw new Error(`Player not found for assignment transaction: ${data.playerId}`);
      }

      const player = playersData[playerIndex];
      const updatedPlayers = [...playersData];
      updatedPlayers[playerIndex] = {
        ...player,
        balance: (player.balance || 0) + data.total, // Add to balance owed
        totalSpent: (player.totalSpent || 0) + data.total,
        totalPurchases: (player.totalPurchases || 0) + data.quantity,
        updatedAt: normalizedTimestamp,
        version: this.createVersionVector()
      };

      // 4. Save all updates atomically
      await Promise.all([
        this.saveLocalData('assignments', updatedAssignments),
        this.saveLocalData('products', updatedProducts),
        this.saveLocalData('players', updatedPlayers)
      ]);

      console.log('‚úÖ Assignment transaction applied to local cache:', {
        assignmentId: newAssignment.id,
        productStockReduced: data.quantity,
        newStock: updatedProducts[productIndex].stock,
        playerBalanceIncreased: data.total,
        newBalance: updatedPlayers[playerIndex].balance
      });

    } catch (error) {
      console.error('‚ùå Failed to apply assignment transaction:', error);
      throw error;
    }
  }

  // ============================================
  // APPLYOP HELPER FUNCTIONS
  // ============================================

  /**
   * Get local data for a collection (always read local first)
   */
  private async getLocalData(collection: string): Promise<any[]> {
    try {
      const data = await AsyncStorage.getItem(collection);
      return data ? JSON.parse(data) : [];
    } catch (error) {
      console.error(`‚ùå Error reading local ${collection}:`, error);
      return [];
    }
  }

  /**
   * Save data to local cache atomically
   */
  private async saveLocalData(collection: string, data: any[]): Promise<void> {
    try {
      await AsyncStorage.setItem(collection, JSON.stringify(data));
      console.log(`üíæ Saved ${data.length} items to local ${collection}`);
    } catch (error) {
      console.error(`‚ùå Error saving local ${collection}:`, error);
      throw error;
    }
  }

  /**
   * Add operation to outbox for server sync
   */
  private async addOpToOutbox(operation: Operation): Promise<void> {
    console.log('üì§ OUTBOX DEBUG - Adding operation to outbox:', {
      operationId: operation.id,
      type: operation.type,
      collection: operation.collection,
      entityId: operation.entityId,
      currentQueueSize: this.syncQueue.length
    });
    
    // Use the centralized method that checks for duplicates
    this.addToSyncQueue({
      id: operation.id,
      action: operation.type as any,
      collection: operation.collection,
      data: {
        ...operation.data,
        entityId: operation.entityId,
        metadata: operation.metadata
      },
      // Extract batch info from operation data if present
      batchId: operation.data?.batchId,
      batchLabel: operation.data?.batchLabel
    });
    
    console.log('üì§ Operation added to outbox:', operation.id);
    
    // Special logging for player operations
    if (operation.collection === 'players' && operation.type === 'create') {
      console.log('üéØ OUTBOX - Player creation queued:', {
        operationId: operation.id,
        playerId: operation.entityId,
        playerName: operation.data?.name || `${operation.data?.firstName} ${operation.data?.lastName}`,
        queueLength: this.syncQueue.length,
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * Remove operation from outbox after successful sync
   */
  private async removeOpFromOutbox(operationId: string): Promise<void> {
    const initialLength = this.syncQueue.length;
    this.syncQueue = this.syncQueue.filter(item => item.id !== operationId);
    const removedCount = initialLength - this.syncQueue.length;
    
    if (removedCount > 0) {
      await this.saveSyncQueue();
      console.log('üóëÔ∏è Removed operation from outbox:', operationId, `(${removedCount} items removed)`);
    }
  }

  /**
   * Attempt to sync operation to server immediately
   */
  private async syncOpToServer(operation: Operation): Promise<void> {
    const firebaseService = new FirebaseService();
    
    console.log('üî• SYNC TO SERVER - Starting:', {
      collection: operation.collection,
      type: operation.type,
      entityId: operation.entityId,
      operationId: operation.id,
      hasData: !!operation.data,
      timestamp: new Date().toISOString()
    });
    
    switch (operation.collection) {
      case 'players':
        if (operation.type === 'updateBalance') {
          const { entityId, data } = operation;
          console.log('üî• PLAYER BALANCE UPDATE:', { entityId, amount: data.amount, isDebit: data.isDebit });
          await firebaseService.updatePlayerBalance(entityId!, data.amount, data.isDebit);
          console.log('‚úÖ Player balance update completed');
        } else if (operation.type === 'update') {
          console.log('üî• PLAYER UPDATE - Using logical UUID directly:', { 
            entityUUID: operation.entityId, 
            data: operation.data 
          });
          
          // FIXED: FirebaseService.updatePlayer handles logical UUID mapping internally
          const playerUUID = operation.entityId!;
          await firebaseService.updatePlayer(playerUUID, operation.data);
          console.log('‚úÖ Player update completed with logical UUID');
        } else if (operation.type === 'delete') {
          console.log('üóëÔ∏è SYNC TO SERVER - Deleting player:', operation.entityId);
          await firebaseService.deletePlayer(operation.entityId!);
          console.log('‚úÖ Player deleted from Firebase:', operation.entityId);
        } else if (operation.type === 'create') {
          console.log('üî• PLAYER CREATE - Raw operation data:', { 
            originalData: operation.data,
            operationId: operation.id,
            entityId: operation.entityId
          });
          // CRITICAL FIX: Preserve UUID id field, only remove Firebase-generated fields
          const { createdAt, updatedAt, ...playerDataForFirebase } = operation.data;
          console.log('üî• PLAYER CREATE - Data for Firebase (preserving UUID id):', { 
            cleanedData: playerDataForFirebase,
            preservedId: playerDataForFirebase.id,
            removedFields: { createdAt, updatedAt }
          });
          
          try {
            const result = await firebaseService.addPlayer(playerDataForFirebase);
            console.log('‚úÖ Player created in Firebase:', { result, originalId: operation.entityId });
          } catch (error) {
            console.error('‚ùå Firebase player creation failed:', { 
              error: error instanceof Error ? error.message : String(error), 
              data: playerDataForFirebase,
              operationId: operation.id 
            });
            throw error;
          }
        }
        break;
        
      case 'assignments':
        if (operation.type === 'update') {
          await firebaseService.updateAssignment(operation.entityId!, operation.data);
        } else if (operation.type === 'create') {
          // Clean assignment data before sending to Firebase (remove operation metadata)
          const { 
            entityId, 
            metadata, 
            vectorClock, 
            version, 
            deviceId, 
            timestamp,
            createdAt, 
            updatedAt, 
            ...cleanAssignmentData 
          } = operation.data;
          
          console.log('üîÑ Cleaned assignment data for Firebase:', {
            original: operation.data,
            cleaned: cleanAssignmentData,
            removedFields: { entityId, metadata, vectorClock, version, deviceId, timestamp, createdAt, updatedAt }
          });
          
          await firebaseService.addAssignment(cleanAssignmentData);
        } else if (operation.type === 'delete') {
          console.log('üóëÔ∏è SYNC TO SERVER - Deleting assignment:', operation.entityId);
          await firebaseService.deleteAssignment(operation.entityId!);
          console.log('‚úÖ Assignment deleted from Firebase:', operation.entityId);
        }
        break;
        
      case 'products':
        if (operation.type === 'update') {
          console.log('üîÑ SYNC TO SERVER - Product update operation:', {
            entityId: operation.entityId,
            data: operation.data,
            operationId: operation.id,
            dataKeys: Object.keys(operation.data || {}),
            hasStockUpdate: operation.data?.stock !== undefined
          });
          
          try {
            await firebaseService.updateProduct(operation.entityId!, operation.data);
            console.log('‚úÖ SYNC TO SERVER - Product update successful:', {
              productId: operation.entityId,
              updatedFields: Object.keys(operation.data || {}),
              operationId: operation.id
            });
          } catch (error) {
            console.error('‚ùå SYNC TO SERVER - Product update failed:', {
              productId: operation.entityId,
              error: error instanceof Error ? error.message : String(error),
              operationId: operation.id,
              data: operation.data
            });
            throw error;
          }
        } else if (operation.type === 'delete') {
          console.log('üóëÔ∏è SYNC TO SERVER - Deleting product:', operation.entityId);
          await firebaseService.deleteProduct(operation.entityId!);
          console.log('‚úÖ Product deleted from Firebase:', operation.entityId);
        } else if (operation.type === 'create') {
          // Clean product data before sending to Firebase (remove operation metadata)
          const { 
            entityId, 
            metadata, 
            vectorClock, 
            version, 
            deviceId, 
            timestamp,
            createdAt, 
            updatedAt, 
            ...cleanProductData 
          } = operation.data;
          
          console.log('üîÑ Cleaned product data for Firebase:', {
            original: operation.data,
            cleaned: cleanProductData,
            removedFields: { entityId, metadata, vectorClock, version, deviceId, timestamp, createdAt, updatedAt }
          });
          
          await firebaseService.addProduct(cleanProductData);
        }
        break;
        
      case 'staff-users':
        if (operation.type === 'update') {
          console.log('üîÑ SYNC TO SERVER - Staff user update operation:', {
            entityId: operation.entityId,
            data: operation.data,
            operationId: operation.id
          });
          
          try {
            await firebaseService.updateStaffUser(operation.entityId!, operation.data);
            console.log('‚úÖ SYNC TO SERVER - Staff user update successful:', {
              staffUserId: operation.entityId,
              operationId: operation.id
            });
          } catch (error) {
            console.error('‚ùå SYNC TO SERVER - Staff user update failed:', {
              staffUserId: operation.entityId,
              error: error instanceof Error ? error.message : String(error),
              operationId: operation.id,
              data: operation.data
            });
            throw error;
          }
        } else if (operation.type === 'delete') {
          console.log('üóëÔ∏è SYNC TO SERVER - Deleting staff user:', operation.entityId);
          await firebaseService.deleteStaffUser(operation.entityId!);
          console.log('‚úÖ Staff user deleted from Firebase:', operation.entityId);
        } else if (operation.type === 'create') {
          // Clean staff user data before sending to Firebase (remove operation metadata)
          const { 
            entityId, 
            metadata, 
            vectorClock, 
            version, 
            deviceId, 
            timestamp,
            createdAt, 
            updatedAt, 
            ...cleanStaffUserData 
          } = operation.data;
          
          console.log('üîÑ Cleaned staff user data for Firebase:', {
            original: operation.data,
            cleaned: cleanStaffUserData,
            removedFields: { entityId, metadata, vectorClock, version, deviceId, timestamp, createdAt, updatedAt }
          });
          
          await firebaseService.addStaffUser(cleanStaffUserData);
          console.log('‚úÖ Staff user created in Firebase:', operation.entityId);
        }
        break;
        
      default:
        console.warn('‚ö†Ô∏è Server sync not implemented for:', operation.collection);
    }

    // Handle compound operations that affect multiple collections
    if (operation.type === 'createAssignmentTransaction') {
      await this.syncAssignmentTransactionToServer(operation);
    }
    
    console.log('üî• Operation synced to server:', operation.id);
  }

  /**
   * Sync compound assignment transaction to server  
   * FIXED: Proper dependency order and UPSERT logic
   */
  private async syncAssignmentTransactionToServer(operation: Operation): Promise<void> {
    const firebaseService = new FirebaseService();
    
    console.log('üî• ASSIGNMENT TRANSACTION SYNC - Starting compound operation:', {
      assignmentId: operation.entityId,
      productId: operation.data.productId,
      playerId: operation.data.playerId,
      quantity: operation.data.quantity,
      total: operation.data.total
    });

    try {
      // Get the updated entities from local cache (these have the correct state)
      const localProducts = await this.getLocalData('products');
      const localPlayers = await this.getLocalData('players');
      const localAssignments = await this.getLocalData('assignments');
      
      const product = localProducts.find(p => p.id === operation.data.productId);
      const player = localPlayers.find(p => p.id === operation.data.playerId);
      const assignment = localAssignments.find(a => a.id === operation.entityId);
      
      if (!product || !player || !assignment) {
        throw new Error(`Missing entities for assignment transaction: ${operation.entityId}`);
      }

      console.log('ÔøΩ SYNC DEBUG - Entities found:', {
        product: { id: product.id, name: product.name, stock: product.stock },
        player: { id: player.id, name: `${player.firstName} ${player.lastName}`, balance: player.balance },
        assignment: { id: assignment.id, total: assignment.total }
      });

      // STEP 1: Ensure product exists in Firebase (UPSERT)
      const { createdAt: pCreatedAt, updatedAt: pUpdatedAt, version: pVersion, vectorClock: pVectorClock, ...cleanProduct } = product;
      console.log('üì¶ Upserting product to Firebase:', cleanProduct.id);
      await firebaseService.upsertProduct(cleanProduct);
      
      // STEP 2: Ensure player exists in Firebase (UPSERT) 
      const { createdAt: plCreatedAt, updatedAt: plUpdatedAt, version: plVersion, vectorClock: plVectorClock, ...cleanPlayer } = player;
      console.log('üë§ Upserting player to Firebase:', cleanPlayer.id);
      await firebaseService.upsertPlayer(cleanPlayer);

      
      // STEP 3: Create/update assignment in Firebase (UPSERT)
      const { createdAt: aCreatedAt, updatedAt: aUpdatedAt, version: aVersion, vectorClock: aVectorClock, ...cleanAssignment } = assignment;
      console.log('üìã Upserting assignment to Firebase:', cleanAssignment.id);
      await firebaseService.upsertAssignment(cleanAssignment);


        console.log('ÔøΩ Syncing product stock to Firebase:', {
          productId: product.id,
          currentStock: product.stock,
          quantitySold: operation.data.quantity
        });
        
        try {

          console.log('‚úÖ Product stock updated in Firebase:', product.id);
        } catch (error: any) {
          // If product doesn't exist in Firebase, create it first
          if (error.message && error.message.includes('Product with logical ID') && error.message.includes('not found')) {
            console.log('üîß Product not found in Firebase, creating it first:', product.id);
            
            // Clean product data for Firebase (remove local-only fields)
            const { 
              createdAt, 
              updatedAt, 
              version, 
              vectorClock,
              ...cleanProductData 
            } = product;
            
            // No field conversion needed - use 'stock' consistently
            await firebaseService.addProduct(cleanProductData);
            console.log('‚úÖ Product created in Firebase, stock already correct:', product.id);
          } else {
            // Re-throw other errors
            throw error;
          }
        }
      }

      // 3. Update player balance in Firebase (with dependency check)
      const localPlayers = await this.getLocalData('players');
      const player = localPlayers.find(p => p.id === operation.data.playerId);
      if (player) {
        console.log('üë§ Syncing player balance to Firebase:', {
          playerId: player.id,
          newBalance: player.balance,
          totalSpent: player.totalSpent,
          totalPurchases: player.totalPurchases
        });
        
        try {
          await firebaseService.updatePlayer(player.id, {
            balance: player.balance,
            totalSpent: player.totalSpent,
            totalPurchases: player.totalPurchases
          });
          console.log('‚úÖ Player balance updated in Firebase:', player.id);
        } catch (error: any) {
          // If player doesn't exist in Firebase, create it first
          if (error.message && error.message.includes('Player with logical ID') && error.message.includes('not found')) {
            console.log('üîß Player not found in Firebase, creating it first:', player.id);
            
            // Clean player data for Firebase (remove local-only fields)
            const { 
              createdAt, 
              updatedAt, 
              version, 
              vectorClock,
              ...cleanPlayerData 
            } = player;
            
            await firebaseService.addPlayer(cleanPlayerData);
            console.log('‚úÖ Player created in Firebase with correct balance:', player.id);
          } else {
            // Re-throw other errors
            throw error;
          }
        }
      }

      console.log('‚úÖ Assignment transaction synced to server successfully:', operation.entityId);

    } catch (error) {
      console.error('‚ùå Assignment transaction sync failed:', error);
      throw error;
    }
  }

  /**
   * Resolve conflicts using timestamp and vector clock rules
   */
  private async resolveConflicts(currentEntity: any, updates: any, metadata: Operation['metadata']): Promise<any> {
    // Safely convert current timestamp
    let currentUpdatedAt: number;
    try {
      currentUpdatedAt = new Date(currentEntity.updatedAt || 0).getTime();
      if (isNaN(currentUpdatedAt)) {
        currentUpdatedAt = 0;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Invalid currentEntity.updatedAt:', currentEntity.updatedAt);
      currentUpdatedAt = 0;
    }
    
    // Safely convert update timestamp
    let updateTimestamp: number;
    try {
      if (typeof metadata.timestamp === 'string') {
        updateTimestamp = new Date(metadata.timestamp).getTime();
      } else {
        updateTimestamp = metadata.timestamp;
      }
      if (isNaN(updateTimestamp)) {
        throw new Error('Invalid timestamp conversion');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Invalid metadata.timestamp:', metadata.timestamp, error);
      updateTimestamp = Date.now();
    }
    
    console.log('üîÄ Resolving conflicts:', {
      entityId: currentEntity.id,
      currentTime: new Date(currentUpdatedAt).toISOString(),
      updateTime: new Date(updateTimestamp).toISOString(),
      source: metadata.source,
      timestampType: typeof metadata.timestamp
    });

    // Server timestamps always win for server operations
    if (metadata.source === 'server') {
      console.log('üî• Server operation - accepting server state');
      return {
        ...currentEntity,
        ...updates
      };
    }

    // For local operations, use timestamp comparison
    if (updateTimestamp > currentUpdatedAt) {
      console.log('üïê Update is newer - accepting changes');
      return {
        ...currentEntity,
        ...updates
      };
    } else if (updateTimestamp === currentUpdatedAt) {
      // Same timestamp - use vector clock if available
      if (currentEntity.version && metadata.vectorClock) {
        const shouldAccept = this.vectorClockComparison(
          currentEntity.version.vectorClock,
          metadata.vectorClock
        );
        
        if (shouldAccept) {
          console.log('üïê Vector clock comparison - accepting changes');
          return {
            ...currentEntity,
            ...updates
          };
        }
      }
    }
    
    console.log('‚è∏Ô∏è Update is older or concurrent - keeping current state');
    return currentEntity;
  }

  /**
   * Compare vector clocks for conflict resolution
   */
  private vectorClockComparison(current: Record<string, number>, incoming: Record<string, number>): boolean {
    // Simple comparison - in production you'd want more sophisticated logic
    const currentSum = Object.values(current).reduce((sum, val) => sum + val, 0);
    const incomingSum = Object.values(incoming).reduce((sum, val) => sum + val, 0);
    
    return incomingSum > currentSum;
  }

  // ============================================
  // PUBLIC API - ALL WRITES GO THROUGH APPLYOP
  // ============================================

  /**
   * Create operation - wrapper around applyOp
   */
  public async createEntity(collection: string, data: any): Promise<string> {
    const entityId = data.id || generateUUID();
    const operation: Operation = {
      id: generateUUID(),
      type: 'create',
      collection: collection as any,
      entityId,
      data: { ...data, id: entityId },
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    await this.applyOp(operation);
    return entityId;
  }

  /**
   * Update operation - wrapper around applyOp
   */
  public async updateEntity(collection: string, entityId: string, updates: any): Promise<void> {
    const operation: Operation = {
      id: generateUUID(),
      type: 'update',
      collection: collection as any,
      entityId,
      data: updates,
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    await this.applyOp(operation);
  }

  /**
   * Delete operation - wrapper around applyOp
   */
  public async deleteEntity(collection: string, entityId: string): Promise<void> {
    console.log(`üóëÔ∏è Deleting entity via unified system: ${collection}/${entityId}`);
    
    const operation: Operation = {
      id: generateUUID(),
      type: 'delete',
      collection: collection as any,
      entityId,
      data: {}, // Delete operations don't need data
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    await this.applyOp(operation);
    console.log(`‚úÖ Entity deleted via unified system: ${collection}/${entityId}`);
  }

  // ============================================
  // BATCH/GROUPED OPERATIONS FOR UI DISPLAY
  // ============================================

  /**
   * Create entity with batch grouping - wrapper around createEntity
   */
  public async createEntityWithBatch(collection: string, data: any, batchId: string, batchLabel: string): Promise<string> {
    // Add batch info to the data for tracking
    const dataWithBatch = { ...data, batchId, batchLabel };
    return this.createEntity(collection, dataWithBatch);
  }

  /**
   * Update entity with batch grouping - wrapper around updateEntity
   */
  public async updateEntityWithBatch(collection: string, entityId: string, updates: any, batchId: string, batchLabel: string): Promise<void> {
    // Add batch info to the updates for tracking
    const updatesWithBatch = { ...updates, batchId, batchLabel };
    return this.updateEntity(collection, entityId, updatesWithBatch);
  }

  /**
   * Delete entity with batch grouping - wrapper around deleteEntity
   */
  public async deleteEntityWithBatch(collection: string, entityId: string, batchId: string, batchLabel: string): Promise<void> {
    // For deletes, we'll need to modify the applyOp to handle batch info
    return this.deleteEntity(collection, entityId);
  }

  /**
   * Compound Assignment Transaction - Creates assignment and updates related entities atomically
   * 
   * This method handles the complete sale transaction:
   * 1. Creates the assignment record
   * 2. Reduces product stock
   * 3. Updates player balance and stats
   * 
   * All updates happen atomically in a single operation to prevent sync conflicts
   */
  public async createAssignmentTransaction(assignmentData: {
    productId: string;
    productName: string;
    userName: string;
    playerId: string;
    quantity: number;
    unitPrice: number;
    total: number;
    organizationId: string;
    notes?: string;
  }): Promise<string> {
    console.log('üîÑ Creating assignment transaction (atomic):', {
      player: assignmentData.userName,
      product: assignmentData.productName,
      quantity: assignmentData.quantity,
      total: assignmentData.total
    });

    const assignmentId = generateUUID();
    const operation: Operation = {
      id: generateUUID(),
      type: 'createAssignmentTransaction',
      collection: 'assignments',
      entityId: assignmentId,
      data: {
        ...assignmentData,
        id: assignmentId,
        date: new Date().toISOString(),
        paid: false,
        cancelled: false,
        createdAt: Date.now(),
        updatedAt: Date.now()
      },
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    await this.applyOp(operation);
    console.log(`‚úÖ Assignment transaction completed: ${assignmentId}`);
    return assignmentId;
  }

  // ============================================
  // VECTOR CLOCK SUPPORT
  // ============================================

  private generateDeviceId(): string {
    // Generate persistent device ID or retrieve from storage
    return `device_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async initializeVectorClock(): Promise<void> {
    try {
      // Load existing vector clock from storage
      const clockData = await AsyncStorage.getItem('vector_clock');
      if (clockData) {
        const clockObj = JSON.parse(clockData);
        this.vectorClock = new Map(Object.entries(clockObj));
      }
      
      // Initialize this device's counter
      if (!this.vectorClock.has(this.deviceId)) {
        this.vectorClock.set(this.deviceId, 0);
        await this.saveVectorClock();
      }
      
      console.log('üïê Vector clock initialized:', {
        deviceId: this.deviceId,
        clockSize: this.vectorClock.size
      });
    } catch (error) {
      console.error('‚ùå Error initializing vector clock:', error);
    }
  }

  private async saveVectorClock(): Promise<void> {
    try {
      const clockObj = Object.fromEntries(this.vectorClock);
      await AsyncStorage.setItem('vector_clock', JSON.stringify(clockObj));
    } catch (error) {
      console.error('‚ùå Error saving vector clock:', error);
    }
  }

  private incrementVectorClock(): number {
    const currentValue = this.vectorClock.get(this.deviceId) || 0;
    const newValue = currentValue + 1;
    this.vectorClock.set(this.deviceId, newValue);
    this.saveVectorClock(); // Fire and forget
    return newValue;
  }

  private createVersionVector(): any {
    return {
      deviceId: this.deviceId,
      version: this.incrementVectorClock(),
      timestamp: Date.now(),
      vectorClock: Object.fromEntries(this.vectorClock)
    };
  }

  // ============================================
  // ATOMIC OUTBOX TRANSACTIONS
  // ============================================

  /**
   * Performs atomic outbox operation: updates local data + sync queue together
   * This ensures consistency between local state and outbox queue
   */
  private async performAtomicOutboxWrite<T>(
    storageKey: string,
    updateOperation: (currentData: T[]) => T[],
    queueItem: Omit<SyncQueueItem, 'timestamp' | 'retryCount'>
  ): Promise<void> {
    try {
      // Get current data
      const currentDataStr = await AsyncStorage.getItem(storageKey);
      const currentData: T[] = currentDataStr ? JSON.parse(currentDataStr) : [];
      
      // Apply update operation
      const updatedData = updateOperation(currentData);
      
      // Prepare batch operations
      const operations = [
        AsyncStorage.setItem(storageKey, JSON.stringify(updatedData)),
        this.addToSyncQueueAtomic(queueItem)
      ];
      
      // Execute atomically
      await Promise.all(operations);
      
      console.log(`üíæ Atomic outbox write completed for ${storageKey}`, {
        itemCount: updatedData.length,
        queueItemId: queueItem.id
      });
      
    } catch (error) {
      console.error(`‚ùå Atomic outbox write failed for ${storageKey}:`, error);
      throw error;
    }
  }

  private async addToSyncQueueAtomic(item: Omit<SyncQueueItem, 'timestamp' | 'retryCount'>): Promise<void> {
    this.syncQueue.push({
      ...item,
      timestamp: Date.now(),
      retryCount: 0
    });
    await this.saveSyncQueue();
  }

  // ============================================
  // NETWORK MONITORING
  // ============================================
  
  private async initializeNetworkListener(): Promise<void> {
    // Get initial network state
    const netInfo = await NetInfo.fetch();
    this.isOnline = netInfo.isConnected ?? false;
    
    console.log('üåê Network initialized', {
      isConnected: netInfo.isConnected,
      type: netInfo.type,
      isInternetReachable: netInfo.isInternetReachable,
      details: netInfo.details
    });
    
    // Listen for network changes
    NetInfo.addEventListener((state: NetInfoState) => {
      const wasOffline = !this.isOnline;
      const previousOnlineState = this.isOnline;
      
      // More strict offline detection - check both connection AND internet reachability
      const newOnlineState = (state.isConnected === true) && (state.isInternetReachable !== false);
      this.isOnline = newOnlineState;
      
      console.log('üì° Network state changed', {
        previousState: previousOnlineState,
        newState: this.isOnline,
        rawIsConnected: state.isConnected,
        rawIsInternetReachable: state.isInternetReachable,
        type: state.type,
        details: state.details,
        queueLength: this.syncQueue.length,
        timestamp: new Date().toLocaleTimeString()
      });
      
      // If we just came back online, trigger sync
      if (wasOffline && this.isOnline) {
        console.log('üì∂ Network restored, triggering sync...', {
          queueLength: this.syncQueue.length
        });
        this.processSyncQueue();
      }
      
      // If we just went offline
      if (!wasOffline && !this.isOnline) {
        console.log('üìµ Network lost - switching to offline mode');
      }
    });
  }

  // ============================================
  // SYNC QUEUE MANAGEMENT
  // ============================================
  
  private async loadSyncQueue(): Promise<void> {
    try {
      const queueData = await AsyncStorage.getItem(this.syncQueueKey);
      const rawQueue: SyncQueueItem[] = queueData ? JSON.parse(queueData) : [];
      
      // Validate and filter out corrupted items
      const validItems: SyncQueueItem[] = [];
      const invalidItems: any[] = [];
      const orphanedProductItems: any[] = [];
      
      for (const item of rawQueue) {
        if (this.isValidSyncQueueItem(item)) {
          // Additional validation for product operations - check if product exists
          if (item.collection === 'products' && (item.action === 'update' || item.action === 'delete')) {
            const productExists = await this.checkProductExists(item.id);
            if (!productExists) {
              orphanedProductItems.push(item);
              console.warn('üóëÔ∏è Found orphaned product sync item (product no longer exists):', {
                productId: item.id,
                action: item.action,
                data: item.data,
                timestamp: new Date(item.timestamp).toISOString()
              });
              continue;
            }
          }
          // Additional validation for assignment operations - check if assignment exists
          else if (item.collection === 'assignments' && (item.action === 'update' || item.action === 'delete')) {
            const assignmentExists = await this.checkAssignmentExists(item.id);
            if (!assignmentExists) {
              orphanedProductItems.push(item); // Reusing the same array for simplicity
              console.warn('üóëÔ∏è Found orphaned assignment sync item (assignment no longer exists):', {
                assignmentId: item.id,
                action: item.action,
                data: item.data,
                timestamp: new Date(item.timestamp).toISOString()
              });
              continue;
            }
          }
          validItems.push(item);
        } else {
          invalidItems.push(item);
          console.warn('‚ö†Ô∏è Found invalid sync queue item:', {
            item: item,
            missingFields: this.getMissingFields(item)
          });
        }
      }
      
      this.syncQueue = validItems;
      
      console.log(`üìã Loaded sync queue: ${validItems.length} valid items, ${invalidItems.length} invalid items, ${orphanedProductItems.length} orphaned product items filtered out`);
      
      if (invalidItems.length > 0 || orphanedProductItems.length > 0) {
        // Save the cleaned queue back to storage
        await this.saveSyncQueue();
        console.log('üßπ Cleaned and saved sync queue after filtering invalid/orphaned items');
      }

      // If we still have a suspicious number of items, log details for debugging
      if (validItems.length > 5) {
        console.log('‚ö†Ô∏è Large sync queue detected - running debug inspection');
        await this.debugSyncQueue();
      }
      
    } catch (error) {
      console.error('Error loading sync queue:', error);
      this.syncQueue = [];
    }
  }

  private isValidSyncQueueItem(item: any): item is SyncQueueItem {
    return item && 
           typeof item.id === 'string' &&
           typeof item.collection === 'string' &&
           typeof item.action === 'string' &&
           item.data !== null &&
           item.data !== undefined &&
           typeof item.timestamp === 'number' &&
           typeof item.retryCount === 'number';
  }

  private getMissingFields(item: any): string[] {
    const required = ['id', 'collection', 'action', 'data', 'timestamp', 'retryCount'];
    const missing: string[] = [];
    
    for (const field of required) {
      if (!item || item[field] === null || item[field] === undefined) {
        missing.push(field);
      }
    }
    
    return missing;
  }

  private async checkProductExists(productId: string): Promise<boolean> {
    try {
      const products = await this.getLocalData('products');
      const productExists = products.some((product: any) => product.id === productId);
      console.log(`üîç Product existence check: ${productId} = ${productExists}`);
      return productExists;
    } catch (error) {
      console.error('Error checking product existence:', error);
      return false; // Assume doesn't exist if we can't check
    }
  }

  private async checkAssignmentExists(assignmentId: string): Promise<boolean> {
    try {
      const assignments = await this.getLocalData('assignments');
      const assignmentExists = assignments.some((assignment: any) => assignment.id === assignmentId);
      console.log(`üîç Assignment existence check: ${assignmentId} = ${assignmentExists}`);
      return assignmentExists;
    } catch (error) {
      console.error('Error checking assignment existence:', error);
      return false; // Assume doesn't exist if we can't check
    }
  }

  /**
   * Debug method to inspect sync queue contents
   */
  public async debugSyncQueue(): Promise<void> {
    console.log('üîç === SYNC QUEUE DEBUG INSPECTION ===');
    console.log(`üìä Total items in sync queue: ${this.syncQueue.length}`);
    
    if (this.syncQueue.length === 0) {
      console.log('‚úÖ Sync queue is empty');
      return;
    }

    // Group by collection and action
    const grouped: { [key: string]: SyncQueueItem[] } = {};
    
    for (const item of this.syncQueue) {
      const key = `${item.collection}_${item.action}`;
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(item);
    }

    // Log summary
    console.log('üìã Sync queue breakdown:');
    for (const [key, items] of Object.entries(grouped)) {
      console.log(`  ${key}: ${items.length} items`);
    }

    // Log detailed information for each item
    console.log('üìù Detailed sync queue items:');
    for (let i = 0; i < this.syncQueue.length; i++) {
      const item = this.syncQueue[i];
      const age = Date.now() - item.timestamp;
      const ageMinutes = Math.round(age / (1000 * 60));
      
      console.log(`  ${i + 1}. ${item.collection}/${item.action} (${item.id})`);
      console.log(`     Age: ${ageMinutes} minutes`);
      console.log(`     Retry count: ${item.retryCount}`);
      console.log(`     Data keys: ${item.data ? Object.keys(item.data).join(', ') : 'no data'}`);
      
      // Special handling for products - check if they exist
      if (item.collection === 'products') {
        const exists = await this.checkProductExists(item.id);
        console.log(`     Product exists: ${exists}`);
        if (!exists) {
          console.log(`     ‚ö†Ô∏è  ORPHANED: Product ${item.id} no longer exists!`);
        }
      }
      // Special handling for assignments - check if they exist
      else if (item.collection === 'assignments') {
        const exists = await this.checkAssignmentExists(item.id);
        console.log(`     Assignment exists: ${exists}`);
        if (!exists) {
          console.log(`     ‚ö†Ô∏è  ORPHANED: Assignment ${item.id} no longer exists!`);
        }
      }
    }
    
    console.log('üîç === END SYNC QUEUE DEBUG ===');
  }

  /**
   * Clean orphaned and invalid items from sync queue
   */
  public async cleanSyncQueue(): Promise<{ removed: number; kept: number }> {
    console.log('üßπ Starting sync queue cleanup...');
    
    const originalCount = this.syncQueue.length;
    const validItems: SyncQueueItem[] = [];
    let removedCount = 0;

    for (const item of this.syncQueue) {
      let shouldKeep = true;

      // Check if item is valid
      if (!this.isValidSyncQueueItem(item)) {
        console.log(`üóëÔ∏è Removing invalid sync item: ${(item as any)?.id || 'unknown'}`);
        shouldKeep = false;
        removedCount++;
      }
      // Check if product operations reference existing products
      else if (item.collection === 'products' && (item.action === 'update' || item.action === 'delete')) {
        const productExists = await this.checkProductExists(item.id);
        if (!productExists) {
          console.log(`üóëÔ∏è Removing orphaned product sync item: ${item.id} (${item.action})`);
          shouldKeep = false;
          removedCount++;
        }
      }
      // Check if assignment operations reference existing assignments
      else if (item.collection === 'assignments' && (item.action === 'update' || item.action === 'delete')) {
        const assignmentExists = await this.checkAssignmentExists(item.id);
        if (!assignmentExists) {
          console.log(`üóëÔ∏è Removing orphaned assignment sync item: ${item.id} (${item.action})`);
          shouldKeep = false;
          removedCount++;
        }
      }
      // Check age - remove items older than 1 hour that have high retry counts
      else if (item.retryCount >= this.maxRetries / 2) {
        const age = Date.now() - item.timestamp;
        const oneHour = 60 * 60 * 1000;
        if (age > oneHour) {
          console.log(`üóëÔ∏è Removing stale sync item: ${item.id} (age: ${Math.round(age / (1000 * 60))} minutes, retries: ${item.retryCount})`);
          shouldKeep = false;
          removedCount++;
        }
      }

      if (shouldKeep) {
        validItems.push(item);
      }
    }

    this.syncQueue = validItems;
    await this.saveSyncQueue();

    const result = { removed: removedCount, kept: validItems.length };
    console.log(`‚úÖ Sync queue cleanup completed: removed ${result.removed}, kept ${result.kept}`);
    
    return result;
  }

  private async saveSyncQueue(): Promise<void> {
    try {
      await AsyncStorage.setItem(this.syncQueueKey, JSON.stringify(this.syncQueue));
    } catch (error) {
      console.error('Error saving sync queue:', error);
    }
  }

  private addToSyncQueue(item: Omit<SyncQueueItem, 'timestamp' | 'retryCount'>): void {
    // Check for duplicates before adding
    const existingItem = this.syncQueue.find(qItem => 
      qItem.id === item.id && 
      qItem.collection === item.collection && 
      qItem.action === item.action
    );
    
    if (existingItem) {
      console.warn(`‚ö†Ô∏è DUPLICATE SYNC ITEM DETECTED - Not adding:`, {
        itemId: item.id,
        collection: item.collection,
        action: item.action,
        existingTimestamp: new Date(existingItem.timestamp).toISOString(),
        attemptedTimestamp: new Date().toISOString()
      });
      return; // Don't add duplicate
    }
    
    const syncItem: SyncQueueItem = {
      ...item,
      timestamp: Date.now(),
      retryCount: 0
    };
    
    this.syncQueue.push(syncItem);
    this.saveSyncQueue();
    console.log(`‚ûï Added ${item.action} ${item.collection} to sync queue: ${item.id}`);
    console.log(`üìä Sync queue now has ${this.syncQueue.length} items`);
    
    // Log detailed breakdown if queue is getting large
    if (this.syncQueue.length > 3) {
      const breakdown: { [key: string]: number } = {};
      this.syncQueue.forEach(qItem => {
        const key = `${qItem.collection}_${qItem.action}`;
        breakdown[key] = (breakdown[key] || 0) + 1;
      });
      console.log('üìã Queue breakdown:', breakdown);
    }
  }

  private removeFromSyncQueue(id: string): void {
    this.syncQueue = this.syncQueue.filter(item => item.id !== id);
    this.saveSyncQueue();
  }

  // ============================================
  // BACKGROUND SYNC
  // ============================================
  
  private startBackgroundSync(): void {
    console.log('üîÑ Starting enterprise outbox draining timers...');
    
    // High Priority: Every 5 seconds for critical operations (payments, assignments)
    setInterval(() => {
      const auth = getAuth();
      if (this.isOnline && auth.currentUser && this.hasHighPriorityItems() && !this.isSyncing) {
        console.log(`üö® High priority outbox drain triggered`);
        this.processSyncQueue().catch(error => {
          console.warn('High priority sync failed gracefully:', error);
        });
      }
    }, 5000);

    // Normal Priority: Every 15 seconds for regular sync items
    this.syncInterval = setInterval(() => {
      const auth = getAuth();
      if (this.isOnline && auth.currentUser && this.syncQueue.length > 0 && !this.isSyncing) {
        console.log(`üì§ Regular outbox drain triggered: ${this.syncQueue.length} items queued`);
        this.processSyncQueue().catch(error => {
          console.warn('Regular sync failed gracefully:', error);
        });
      }
    }, 15000);

    // Low Priority: Every 60 seconds for comprehensive conflict detection and cleanup
    setInterval(() => {
      const auth = getAuth();
      if (this.isOnline && auth.currentUser && !this.isSyncing) {
        this.performConflictDetectionSync();
        this.cleanupProcessedIds(); // Prevent memory bloat
      }
    }, 60000);

    // Dead Letter Queue Processing: Every 10 minutes
    setInterval(() => {
      const auth = getAuth();
      if (this.isOnline && auth.currentUser && this.deadLetterQueue.length > 0) {
        this.processDeadLetterQueue();
      }
    }, 600000); // 10 minutes

    // Legacy player balance sync removed - now handled via applyOp operations
    // All balance updates flow through the unified write path automatically
  }

  // Legacy player balance sync removed - now handled via applyOp operations
  // All balance updates flow through the unified write path automatically

  private async performConflictDetectionSync(): Promise<void> {
    try {
      // Simple background sync without full conflict resolution to avoid heavy operations
      // Just try to sync pending items gracefully
      if (this.syncQueue.length > 0) {
        await this.processSyncQueue();
      }
    } catch (error) {
      // Silently handle background sync errors
    }
  }

  public async processSyncQueue(): Promise<void> {
    return this.drainOutboxWithTransaction();
  }

  // ============================================
  // ENTERPRISE OUTBOX DRAINING
  // ============================================

  /**
   * Enterprise-grade outbox draining with idempotent transactions
   * Processes items in atomic batches with proper error handling
   */
  private async drainOutboxWithTransaction(): Promise<void> {
    if (this.isSyncing || !this.isOnline || this.syncQueue.length === 0) {
      return;
    }

    this.isSyncing = true;
    
    try {
      // Get items ready for processing with idempotency check
      const itemsToProcess = await this.getItemsReadyForSync();
      
      if (itemsToProcess.length === 0) {
        return;
      }

      console.log(`üîÑ Draining outbox: ${itemsToProcess.length} items in ${Math.ceil(itemsToProcess.length / this.batchSize)} batches`);
      
      // Process in atomic batches
      const batches = this.createBatches(itemsToProcess, this.batchSize);
      
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        console.log(`üì¶ Processing batch ${i + 1}/${batches.length} (${batch.length} items)`);
        
        await this.processBatchTransaction(batch);
        
        // Small delay between batches to prevent overwhelming the server
        if (i < batches.length - 1) {
          await this.delay(100); // 100ms between batches
        }
      }
      
      console.log('‚úÖ Outbox drain completed successfully');
      
    } catch (error) {
      console.error('‚ùå Outbox drain failed:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * Get items ready for sync with idempotency filtering
   */
  private async getItemsReadyForSync(): Promise<SyncQueueItem[]> {
    const currentTime = Date.now();
    
    return this.syncQueue.filter(item => {
      // Skip if already processed (idempotency)
      if (this.processedIds.has(item.id)) {
        console.log(`‚è≠Ô∏è Skipping already processed item: ${item.id}`);
        return false;
      }
      
      // Skip if not ready for retry (backoff delay)
      if (item.timestamp > currentTime) {
        return false;
      }
      
      return true;
    }).sort((a, b) => a.timestamp - b.timestamp); // Oldest first for FIFO processing
  }

  /**
   * Process a batch of items as an atomic transaction
   */
  private async processBatchTransaction(batch: SyncQueueItem[]): Promise<void> {
    const batchId = `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    console.log(`üîÑ Starting transaction ${batchId} with ${batch.length} items`);
    
    const processedInBatch: string[] = [];
    const failedInBatch: SyncQueueItem[] = [];
    
    try {
      // Process each item in the batch
      for (const item of batch) {
        try {
          // Double-check idempotency at item level
          if (this.processedIds.has(item.id)) {
            console.log(`‚è≠Ô∏è Item ${item.id} already processed, skipping`);
            continue;
          }
          
          await this.syncItemIdempotent(item);
          
          // Mark as processed for idempotency
          this.processedIds.add(item.id);
          processedInBatch.push(item.id);
          
          console.log(`‚úÖ Processed item ${item.id} in batch ${batchId}`);
          
        } catch (error) {
          console.warn(`‚ö†Ô∏è Item ${item.id} failed in batch ${batchId}:`, error);
          failedInBatch.push(item);
        }
      }
      
      // Atomic cleanup: Remove successful items from queue
      if (processedInBatch.length > 0) {
        this.removeMultipleFromSyncQueue(processedInBatch);
        console.log(`üßπ Removed ${processedInBatch.length} processed items from queue`);
      }
      
      // Handle failed items with retry logic or dead letter queue
      if (failedInBatch.length > 0) {
        await this.handleFailedItems(failedInBatch, batchId);
      }
      
    } catch (batchError) {
      console.error(`‚ùå Batch transaction ${batchId} failed:`, batchError);
      // Rollback: Remove idempotency markers for this batch
      processedInBatch.forEach(id => this.processedIds.delete(id));
      throw batchError;
    }
    
    // Persist queue changes
    await this.saveSyncQueue();
    
    console.log(`‚úÖ Batch transaction ${batchId} completed: ${processedInBatch.length} success, ${failedInBatch.length} failed`);
  }

  /**
   * Idempotent sync item processing - safe to call multiple times
   */
  private async syncItemIdempotent(item: SyncQueueItem): Promise<void> {
    // Check if this specific operation was already completed successfully
    const operationKey = `${item.collection}_${item.action}_${item.id}`;
    
    try {
      await this.syncItem(item);
      
      // Mark operation as completed for future idempotency checks
      console.log(`‚úÖ Idempotent sync completed: ${operationKey}`);
      
    } catch (error) {
      console.error(`‚ùå Idempotent sync failed: ${operationKey}`, error);
      throw error;
    }
  }

  /**
   * Create batches from items array
   */
  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * Remove multiple items from sync queue atomically
   */
  private removeMultipleFromSyncQueue(ids: string[]): void {
    this.syncQueue = this.syncQueue.filter(item => !ids.includes(item.id));
  }

  /**
   * Handle failed items with dead letter queue
   */
  private async handleFailedItems(failedItems: SyncQueueItem[], batchId: string): Promise<void> {
    for (const item of failedItems) {
      const queueItem = this.syncQueue.find(q => q.id === item.id);
      if (queueItem) {
        queueItem.retryCount++;
        
        if (queueItem.retryCount >= this.maxRetries) {
          // Move to dead letter queue
          console.warn(`üíÄ Moving item to dead letter queue after ${this.maxRetries} retries: ${item.id}`);
          this.deadLetterQueue.push({ ...queueItem });
          this.removeFromSyncQueue(item.id);
          
          // Persist dead letter queue
          await this.saveDeadLetterQueue();
        } else {
          // Schedule retry with exponential backoff
          const backoffDelay = Math.min(1000 * Math.pow(2, queueItem.retryCount), 300000); // Max 5 minutes
          queueItem.timestamp = Date.now() + backoffDelay;
          
          console.log(`‚è≥ Retry ${queueItem.retryCount}/${this.maxRetries} scheduled in ${Math.round(backoffDelay/1000)}s: ${item.id}`);
        }
      }
    }
  }

  /**
   * Utility delay function
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Save dead letter queue to persistent storage
   */
  private async saveDeadLetterQueue(): Promise<void> {
    try {
      await AsyncStorage.setItem('dead_letter_queue', JSON.stringify(this.deadLetterQueue));
    } catch (error) {
      console.error('‚ùå Error saving dead letter queue:', error);
    }
  }

  private async syncItem(item: SyncQueueItem): Promise<void> {
    switch (item.collection) {
      case 'products':
        return this.syncProductItem(item);
      case 'staff-users':
        return this.syncUserItem(item);
      case 'assignments':
        return this.syncAssignmentItem(item);
      case 'players':
        return this.syncPlayerItem(item);
      case 'reports':
        return this.syncReportItem(item);
      default:
        throw new Error(`Unknown collection: ${item.collection}`);
    }
  }

  private async syncProductItem(item: SyncQueueItem): Promise<void> {
    console.log('üîÑ syncProductItem - Processing item:', {
      itemId: item.id,
      action: item.action,
      collection: item.collection,
      dataKeys: item.data ? Object.keys(item.data) : 'NO DATA',
      hasValidData: !!item.data,
      timestamp: item.timestamp,
      retryCount: item.retryCount
    });

    // Validate item data
    if (!item.data) {
      throw new Error(`Invalid sync item: missing data for product ${item.id}`);
    }

    switch (item.action) {
      case 'create':
        // Clean product data before sending to Firebase (same as syncOpToServer)
        const { 
          entityId, 
          metadata, 
          vectorClock, 
          version, 
          deviceId, 
          timestamp,
          createdAt, 
          updatedAt, 
          ...cleanProductData 
        } = item.data;
        
        console.log('üîÑ Cleaned product data for Firebase (sync queue):', {
          original: item.data,
          cleaned: cleanProductData,
          removedFields: { entityId, metadata, vectorClock, version, deviceId, timestamp, createdAt, updatedAt }
        });
        
        await firebaseService.addProduct(cleanProductData);
        break;
      case 'update':
        // Validate update data
        if (!item.data || typeof item.data !== 'object') {
          throw new Error(`Invalid update data for product ${item.id}: ${JSON.stringify(item.data)}`);
        }

        // Check for undefined values
        const undefinedKeys = Object.keys(item.data).filter(key => item.data[key] === undefined);
        if (undefinedKeys.length > 0) {
          console.warn('‚ö†Ô∏è SYNC QUEUE - Found undefined values in product update:', undefinedKeys);
          // Clean the data
          const cleanData = { ...item.data };
          undefinedKeys.forEach(key => delete cleanData[key]);
          item.data = cleanData;
          console.log('ÔøΩ SYNC QUEUE - Cleaned update data:', cleanData);
        }

        console.log('ÔøΩüîÑ SYNC QUEUE - Product update operation:', {
          itemId: item.id,
          dataId: item.data.id,
          data: item.data,
          dataKeys: Object.keys(item.data),
          usingId: item.id // Use the same logic as syncOpToServer
        });
        // Check if product still exists locally (for logging, but don't skip if missing)
        const productExists = await this.checkProductExists(item.id);
        if (!productExists) {
          console.warn('‚ö†Ô∏è SYNC QUEUE - Product not found in local cache, but attempting Firebase update anyway:', item.id);
          // Don't return - continue with Firebase update as product might exist on server
        }
        
        try {
          await firebaseService.updateProduct(item.id, item.data);
          console.log('‚úÖ SYNC QUEUE - Product updated successfully in Firebase:', {
            productId: item.id,
            updatedFields: Object.keys(item.data || {}),
            hasStockUpdate: item.data?.stock !== undefined,
            itemId: item.id
          });
        } catch (error: any) {
          // Check if error is due to product not existing in Firebase
          if (error.message && (error.message.includes('not found') || error.message.includes('Product with logical ID') && error.message.includes('not found'))) {
            console.warn('‚ö†Ô∏è SYNC QUEUE - Product no longer exists in Firebase, skipping update:', {
              productId: item.id,
              error: error.message,
              updateData: item.data
            });
            return; // Skip this operation instead of retrying
          }
          
          console.error('‚ùå Failed to update product in Firebase:', {
            productId: item.id,
            data: item.data,
            error: error.message,
            errorCode: error.code,
            fullError: error
          });
          throw error; // Re-throw to trigger retry mechanism for other errors
        }
        break;
      case 'delete':
        try {
          await firebaseService.deleteProduct(item.data.id);
          console.log('‚úÖ Product deleted from Firebase:', item.data.id);
        } catch (error: any) {
          // Handle case where document doesn't exist (already deleted or never existed)
          if (error?.message?.includes('No document to update') || 
              error?.code === 'not-found' || 
              error?.message?.includes('not-found')) {
            console.log('üìù Product already deleted or never existed in Firebase:', item.data.id);
            // Treat as successful - the end result is the same (product is gone)
            return;
          }
          // Re-throw other errors
          throw error;
        }
        break;
    }
  }

  private async syncUserItem(item: SyncQueueItem): Promise<void> {
    switch (item.action) {
      case 'create':
        await firebaseService.addUser(item.data);
        break;
      case 'update':
        await firebaseService.updateUser(item.data.uid, item.data);
        break;
      case 'delete':
        // Mark user as inactive instead of deleting
        await firebaseService.updateUser(item.data.uid, { isActive: false });
        break;
    }
  }

  private async syncAssignmentItem(item: SyncQueueItem): Promise<void> {
    switch (item.action) {
      case 'create':
        // Clean assignment data before sending to Firebase (same as syncOpToServer)
        const { 
          entityId: _entityId, 
          metadata: _metadata, 
          vectorClock, 
          version, 
          deviceId, 
          timestamp,
          createdAt, 
          updatedAt, 
          ...cleanAssignmentData 
        } = item.data;
        
        console.log('üîÑ Cleaned assignment data for Firebase (sync queue):', {
          original: item.data,
          cleaned: cleanAssignmentData,
          removedFields: { _entityId, _metadata, vectorClock, version, deviceId, timestamp, createdAt, updatedAt }
        });
        
        // Simple approach: Let Firebase generate the ID and use it everywhere
        const firebaseId = await firebaseService.addAssignment(cleanAssignmentData);
        
        // Update local storage to use the Firebase ID
        const localAssignments = await this.getLocalAssignments();
        const assignmentIndex = localAssignments.findIndex(a => a.id === item.data.id);
        if (assignmentIndex >= 0) {
          // Replace the assignment with Firebase ID
          localAssignments[assignmentIndex] = { ...localAssignments[assignmentIndex], id: firebaseId };
          await AsyncStorage.setItem('assignments', JSON.stringify(localAssignments));
          console.log(`‚úÖ Assignment synced to Firebase with ID: ${firebaseId}`);
        }
        break;
      case 'update':
        console.log(`üîÑ Syncing assignment update:`, {
          queueItemId: item.id,
          dataKeys: Object.keys(item.data),
          itemData: item.data
        });
        
        // For assignment updates, we need to find the assignment ID
        // It could be in item.data.entityId (from applyOp) or item.data.id (old format)
        const assignmentId = item.data.entityId || item.data.id;
        
        if (!assignmentId) {
          console.error('Assignment update missing ID:', item.data);
          throw new Error('Assignment update missing assignment ID');
        }
        
        // Create clean update object without metadata fields
        const { entityId, metadata, ...updateData } = item.data;
        
        // Check if assignment still exists locally before attempting Firebase update
        const assignmentExists = await this.checkAssignmentExists(assignmentId);
        if (!assignmentExists) {
          console.log('‚ö†Ô∏è SYNC QUEUE - Assignment no longer exists locally, skipping update:', assignmentId);
          return; // Skip this operation
        }
        
        try {
          await new FirebaseService().updateAssignment(assignmentId, updateData);
          console.log('‚úÖ Assignment updated successfully in Firebase:', assignmentId);
        } catch (error: any) {
          // Check if error is due to assignment not existing in Firebase
          if (error.message && error.message.includes('not found')) {
            console.log('‚ö†Ô∏è SYNC QUEUE - Assignment no longer exists in Firebase, skipping update:', assignmentId);
            return; // Skip this operation instead of retrying
          }
          
          console.error('‚ùå Failed to update assignment in Firebase:', {
            assignmentId,
            updateData,
            error: error.message,
            errorCode: error.code,
            fullError: error
          });
          throw error; // Re-throw to trigger retry mechanism for other errors
        }
        break;
      case 'delete':
        const deleteAssignmentId = item.data.entityId || item.data.id;
        if (!deleteAssignmentId) {
          throw new Error('Assignment delete missing assignment ID');
        }
        await firebaseService.deleteAssignment(deleteAssignmentId);
        console.log('‚úÖ Assignment deleted from Firebase:', deleteAssignmentId);
        break;
    }
  }



  private async syncPlayerItem(item: SyncQueueItem): Promise<void> {
    try {
      console.log('üîÑ SYNC PLAYER ITEM:', {
        action: item.action,
        playerId: item.data.id || item.data.entityId,
        hasData: !!item.data,
        itemId: item.id
      });
      
      const fbService = new FirebaseService();
      
      switch (item.action) {
        case 'create':
          console.log('üîÑ Syncing player CREATE to Firebase - Raw item.data:', item.data);
          
          // CRITICAL FIX: Extract only player fields from operation data
          // item.data may contain operation metadata, we need just the player fields
          const { 
            entityId, 
            metadata, 
            vectorClock, 
            version, 
            deviceId, 
            timestamp,
            createdAt, 
            updatedAt, 
            ...cleanPlayerData 
          } = item.data;
          
          console.log('üîÑ Cleaned player data for Firebase:', {
            original: item.data,
            cleaned: cleanPlayerData,
            removedFields: { entityId, metadata, vectorClock, version, deviceId, timestamp, createdAt, updatedAt }
          });
          
          // Validate we have essential player fields
          if (!cleanPlayerData.firstName || !cleanPlayerData.lastName || !cleanPlayerData.id) {
            console.error('‚ùå Missing essential player fields:', cleanPlayerData);
            throw new Error('Invalid player data - missing firstName, lastName, or id');
          }
          
          // Check if player already exists in Firebase (prevent duplicates)
          try {
            const existingPlayers = await fbService.getPlayers();
            const existingPlayer = existingPlayers.find(p => p.id === cleanPlayerData.id);
            
            if (existingPlayer) {
              console.log('‚ö†Ô∏è Player already exists in Firebase, skipping create:', cleanPlayerData.id);
              return; // Skip this sync operation
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not check for existing players, proceeding with create:', error);
          }
          
          await fbService.addPlayer(cleanPlayerData);
          console.log('‚úÖ Player CREATE synced to Firebase with clean data');
          break;
          
        case 'updateBalance':
          const { playerId, amount, isDebit } = item.data;
          await fbService.updatePlayerBalance(playerId, amount, isDebit);
          console.log('‚úÖ Player balance update synced to Firebase:', {
            playerId,
            amount,
            isDebit
          });
          break;
          
        case 'update':
          console.log('üîÑ Syncing player UPDATE to Firebase:', {
            playerId: item.data.id,
            updates: item.data
          });
          
          // FIXED: FirebaseService.updatePlayer handles logical UUID mapping internally
          const playerUUID = item.data.id || item.data.entityId;
          if (!playerUUID) {
            throw new Error('No player UUID provided for update');
          }
          
          console.log('üîç Updating player with logical UUID:', { uuid: playerUUID, data: item.data });
          
          // Update using logical UUID - Firebase service handles the mapping internally
          await fbService.updatePlayer(playerUUID, item.data);
          console.log('‚úÖ Player UPDATE synced to Firebase');
          break;
          
        default:
          console.warn('‚ùå Unknown player action:', item.action);
          throw new Error(`Unknown player action: ${item.action}`);
      }
    } catch (error) {
      console.error('‚ùå Error syncing player item:', error);
      throw error;
    }
  }

  private async syncReportItem(item: SyncQueueItem): Promise<void> {
    switch (item.action) {
      case 'create':
        await firebaseService.addReport(item.data);
        break;
      case 'update':
        // For now, skip update as reports don't have update method
        console.log('Report update not implemented yet');
        break;
      case 'delete':
        // For now, skip delete as reports don't have delete method  
        console.log('Report delete not implemented yet');
        break;
    }
  }

  // ============================================
  // PUBLIC API - HYBRID OPERATIONS
  // ============================================

  /**
   * Clean up problematic operations from sync queue
   * Removes operations that are likely to never succeed (like deleting non-existent items)
   */
  public async cleanupSyncQueue(): Promise<void> {
    console.log('üßπ Cleaning up problematic sync queue operations...');
    
    const initialCount = this.syncQueue.length;
    const problemOperations: string[] = [];
    
    // Find operations that have failed too many times with "not found" errors
    const itemsToRemove = this.syncQueue.filter(item => {
      // Remove delete operations that have retried too many times
      if (item.action === 'delete' && item.retryCount >= 2) {
        problemOperations.push(item.id);
        return true;
      }
      
      // Remove update operations for products that have failed with "not found" errors
      if (item.action === 'update' && item.collection === 'products' && item.retryCount >= 2) {
        problemOperations.push(item.id);
        console.log('üßπ Removing orphaned product update operation:', {
          itemId: item.id,
          productId: item.data?.id || item.data?.entityId,
          retryCount: item.retryCount
        });
        return true;
      }
      
      return false;
    });
    
    // Remove problematic operations
    this.syncQueue = this.syncQueue.filter(item => !problemOperations.includes(item.id));
    
    // Also clear dead letter queue of similar items
    const deadLetterInitialCount = this.deadLetterQueue.length;
    this.deadLetterQueue = this.deadLetterQueue.filter(item => {
      return !(item.action === 'delete' && item.collection === 'products');
    });
    
    // Save changes
    await this.saveSyncQueue();
    await this.saveDeadLetterQueue();
    
    console.log(`üßπ Cleanup completed: Removed ${itemsToRemove.length} operations from sync queue (${initialCount} -> ${this.syncQueue.length})`);
    console.log(`üßπ Cleanup completed: Removed ${deadLetterInitialCount - this.deadLetterQueue.length} items from dead letter queue`);
  }

  /**
   * Remove an entity from local cache only (bypass server sync)
   */
  public async removeFromLocalCache(collection: string, entityId: string): Promise<void> {
    try {
      console.log(`üóëÔ∏è Removing ${entityId} from local ${collection} cache`);
      const currentData = await this.getLocalData(collection);
      const filteredData = currentData.filter((item: any) => item.id !== entityId);
      await this.saveLocalData(collection, filteredData);
      console.log(`‚úÖ Removed ${entityId} from local ${collection} cache`);
    } catch (error) {
      console.error(`‚ùå Failed to remove ${entityId} from local ${collection} cache:`, error);
      throw error;
    }
  }

  /**
   * Force clear all local data for a collection (emergency reset)
   */
  public async forceEmptyLocalCollection(collection: string): Promise<void> {
    try {
      console.log(`üßπ Force clearing all local ${collection} data`);
      await this.saveLocalData(collection, []);
      console.log(`‚úÖ Force cleared all local ${collection} data`);
    } catch (error) {
      console.error(`‚ùå Failed to force clear local ${collection} data:`, error);
      throw error;
    }
  }

  /**
   * Remove sync queue items that reference non-existent entities
   */
  public async removeOrphanedSyncItems(): Promise<void> {
    console.log('üßπ Removing orphaned sync queue items...');
    
    const currentProducts = await this.getLocalData('products');
    const currentProductIds = new Set(currentProducts.map((p: any) => p.id));
    
    const initialCount = this.syncQueue.length;
    const orphanedItems: string[] = [];
    
    // Check each sync queue item
    this.syncQueue = this.syncQueue.filter(item => {
      if (item.collection === 'products') {
        const entityId = item.data?.id || item.data?.entityId;
        
        if (!currentProductIds.has(entityId)) {
          orphanedItems.push(item.id);
          console.log('üóëÔ∏è Removing orphaned product sync item:', {
            itemId: item.id,
            action: item.action,
            productId: entityId,
            retryCount: item.retryCount
          });
          return false; // Remove this item
        }
      }
      return true; // Keep this item
    });
    
    await this.saveSyncQueue();
    
    console.log(`üßπ Removed ${orphanedItems.length} orphaned sync items (${initialCount} -> ${this.syncQueue.length})`);
  }

  /**
   * Comprehensive cleanup for current sync issues
   * Call this once to fix the current problematic state
   */
  public async fixCurrentSyncIssues(): Promise<void> {
    console.log('ü©∫ Starting comprehensive sync issues fix...');
    
    try {
      // 1. Remove orphaned sync items first
      await this.removeOrphanedSyncItems();
      
      // 2. Clean up sync queue
      await this.cleanupSyncQueue();
      
      // 2. Remove duplicate products from local storage
      const productsStr = await AsyncStorage.getItem('products');
      if (productsStr) {
        const products = JSON.parse(productsStr);
        const uniqueProducts = [];
        const seenIds = new Set();
        
        for (const product of products) {
          if (!seenIds.has(product.id)) {
            seenIds.add(product.id);
            uniqueProducts.push(product);
          } else {
            console.log('üîÑ Removing duplicate product:', product.id);
          }
        }
        
        await AsyncStorage.setItem('products', JSON.stringify(uniqueProducts));
        console.log(`üßπ Cleaned products: ${products.length} -> ${uniqueProducts.length} items`);
      }
      
      // 3. Remove any products marked as deleted
      const currentProducts = await this.getLocalProducts();
      const activeProducts = currentProducts.filter(p => !p.isDeleted);
      await AsyncStorage.setItem('products', JSON.stringify(activeProducts));
      console.log(`üóëÔ∏è Removed deleted products: ${currentProducts.length} -> ${activeProducts.length} items`);
      
      console.log('‚úÖ Comprehensive sync issues fix completed successfully');
    } catch (error) {
      console.error('‚ùå Fix sync issues failed:', error);
      throw error;
    }
  }

  async addProduct(product: any): Promise<string> {
    console.log('üì¶ Adding product via applyOp system');
    
    // Generate UUID for the product
    const productId = generateUUID();
    const productWithId = { 
      ...product, 
      id: productId,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    
    // Use the unified applyOp system
    await this.applyOp({
      id: generateUUID(),
      type: 'create',
      collection: 'products',
      entityId: productId,
      data: productWithId,
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: 1,
        vectorClock: this.createVersionVector(),
        source: 'local'
      }
    });
    
    console.log('‚úÖ Product added via applyOp:', productId);
    return productId;
  }

  public async updateProduct(id: string, updates: any): Promise<void> {
    console.log('üì¶ updateProduct - using unified applyOp system', {
      productId: id,
      updates: updates,
      updateKeys: Object.keys(updates || {}),
      isOnline: this.isOnline,
      timestamp: new Date().toLocaleTimeString(),
      currentSyncQueueSize: this.syncQueue.length
    });
    
    // Log current sync queue items for debugging
    console.log('üìã Current sync queue before product update:');
    this.syncQueue.forEach((item, index) => {
      console.log(`  ${index + 1}. ${item.collection}/${item.action} - ID: ${item.id} - Age: ${Math.round((Date.now() - item.timestamp) / 1000)}s - Retries: ${item.retryCount}`);
    });

    // ‚úÖ CRITICAL VALIDATION: Ensure product ID is valid before any operations
    if (!id || typeof id !== 'string' || id.length === 0) {
      console.error('‚ùå CRITICAL: Invalid product ID passed to updateProduct:', {
        id: id,
        idType: typeof id,
        idLength: id?.length,
        updates: updates
      });
      throw new Error(`Invalid product ID: ${JSON.stringify(id)}`);
    }
    
    if (!updates || typeof updates !== 'object') {
      console.error('‚ùå CRITICAL: Invalid updates object passed to updateProduct:', {
        updates: updates,
        updatesType: typeof updates,
        productId: id
      });
      throw new Error(`Invalid updates object: ${JSON.stringify(updates)}`);
    }

    // ‚úÖ EXISTENCE CHECK: Verify the product actually exists before updating
    try {
      const existingProducts = await this.getLocalData('products');
      const productExists = existingProducts.some((product: any) => product.id === id);
      
      console.log('üîç PRODUCT EXISTENCE CHECK:', {
        productId: id,
        exists: productExists,
        totalProducts: existingProducts.length,
        existingProductIds: existingProducts.map((p: any) => p.id)
      });
      
      if (!productExists) {
        console.error('‚ùå CRITICAL: Product does not exist in local cache:', {
          productId: id,
          availableProducts: existingProducts.map((p: any) => ({ id: p.id, name: p.name }))
        });
        throw new Error(`Product with ID ${id} does not exist in local cache`);
      }
    } catch (error) {
      console.error('‚ùå Error checking product existence:', error);
      throw error;
    }

    // Check for undefined values in updates
    const undefinedKeys = Object.keys(updates).filter(key => updates[key] === undefined);
    if (undefinedKeys.length > 0) {
      console.warn('‚ö†Ô∏è Warning: undefined values in updates:', undefinedKeys);
      // Remove undefined values to prevent sync issues
      const cleanUpdates = { ...updates };
      undefinedKeys.forEach(key => delete cleanUpdates[key]);
      updates = cleanUpdates;
      console.log('üìù Cleaned updates (removed undefined):', updates);
    }

    // Use the unified applyOp system for consistency and reliability
    await this.applyOp({
      id: generateUUID(),
      type: 'update',
      collection: 'products',
      entityId: id,
      data: updates,
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: 1,
        vectorClock: this.createVersionVector(),
        source: 'local'
      }
    });

    console.log('‚úÖ Product update applied via applyOp system');
    console.log('üîç PRODUCT UPDATE COMPLETE - Final sync queue size:', this.syncQueue.length);
    
    // Log final sync queue state
    console.log('üìã Final sync queue after product update:');
    this.syncQueue.forEach((item, index) => {
      console.log(`  ${index + 1}. ${item.collection}/${item.action} - ID: ${item.id} - Age: ${Math.round((Date.now() - item.timestamp) / 1000)}s - Retries: ${item.retryCount}`);
    });
  }

  public async deleteProduct(id: string): Promise<void> {
    try {
      if (this.isOnline) {
        // Try Firebase first
        try {
          await firebaseService.deleteProduct(id);
          console.log('‚úÖ Product deleted from Firebase:', id);
        } catch (firebaseError: any) {
          // Handle case where document doesn't exist
          if (firebaseError?.message?.includes('No document to update') || 
              firebaseError?.code === 'not-found' || 
              firebaseError?.message?.includes('not-found')) {
            console.log('üìù Product already deleted or never existed in Firebase:', id);
            // Continue to remove from local storage
          } else {
            throw firebaseError;
          }
        }
        
        // Remove from local storage
        await this.removeLocalProduct(id);
      } else {
        throw new Error('Offline - using local storage');
      }
    } catch (error: any) {
      // Only queue for sync if it's not a "document not found" error
      if (!error?.message?.includes('No document to update') && 
          !error?.message?.includes('not-found')) {
        console.log('üì± Marking product as deleted locally and queueing for sync');
        
        // Check if this product is already queued for deletion to prevent duplicates
        const existingDeleteOp = this.syncQueue.find(item => 
          item.collection === 'products' && 
          item.action === 'delete' && 
          item.data?.id === id
        );
        
        if (!existingDeleteOp) {
          // Mark as deleted locally (soft delete)
          await this.updateLocalProduct(id, { isDeleted: true });
          
          // Add to sync queue
          this.addToSyncQueue({
            id: `delete_${generateUUID()}`,
            action: 'delete',
            collection: 'products',
            data: { id }
          });
          console.log('‚ûï Added delete products to sync queue');
        } else {
          console.log('‚è≠Ô∏è Product deletion already queued, skipping duplicate');
        }
      } else {
        // For "not found" errors, just remove locally
        await this.removeLocalProduct(id);
        console.log('üì± Removed non-existent product from local storage:', id);
      }
    }
  }

  // Similar methods for Users, Assignments, Reports...
  async addUser(user: any): Promise<string> {
    try {
      if (this.isOnline) {
        // Try Firebase first - Firebase will generate proper UUID automatically
        const firebaseId = await firebaseService.addUser(user);
        const localUsers = await this.getLocalUsers();
        localUsers.push({ ...user, id: firebaseId });
        await AsyncStorage.setItem('staff-users', JSON.stringify(localUsers));
        return firebaseId;
      } else {
        throw new Error('Offline - using local storage');
      }
    } catch (error) {
      console.log('üì± Saving user locally and queueing for sync');
      
      // Generate proper UUID for offline scenario
      const tempId = `offline_${generateUUID()}`;
      
      // Save locally with temp UUID
      const localUsers = await this.getLocalUsers();
      const userWithId = { ...user, id: tempId };
      localUsers.push(userWithId);
      await AsyncStorage.setItem('staff-users', JSON.stringify(localUsers));
      
      this.addToSyncQueue({
        id: tempId,
        action: 'create',
        collection: 'staff-users',
        data: userWithId
      });
      
      return tempId;
    }
  }

  async addAssignment(assignment: any): Promise<{ id: string; syncStatus: 'synced' | 'pending' }> {
    console.log('ÔøΩ Adding assignment via applyOp system');
    console.log('üîç ASSIGNMENT CREATION DEBUG - Input data:', {
      assignment: assignment,
      currentSyncQueueSize: this.syncQueue.length,
      isOnline: this.isOnline
    });
    
    // Log current sync queue items for debugging
    console.log('üìã Current sync queue before assignment creation:');
    this.syncQueue.forEach((item, index) => {
      console.log(`  ${index + 1}. ${item.collection}/${item.action} - ID: ${item.id} - Age: ${Math.round((Date.now() - item.timestamp) / 1000)}s - Retries: ${item.retryCount}`);
    });
    
    // Generate UUID for the assignment
    const assignmentId = generateUUID();
    const assignmentWithId = { 
      ...assignment, 
      id: assignmentId,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    
    console.log('üÜî Generated assignment ID:', assignmentId);
    
    try {
      // Use the unified applyOp system for both online and offline
      await this.applyOp({
          id: generateUUID(),
          type: 'create',
          collection: 'assignments',
          entityId: assignmentId,
          data: assignmentWithId,
          metadata: {
            deviceId: this.deviceId,
            timestamp: Date.now(),
            version: 1,
            vectorClock: this.createVersionVector(),
            source: 'local'
          }
        });
        console.log('‚úÖ Assignment added via applyOp:', assignmentId);
        console.log('üîç ASSIGNMENT CREATION COMPLETE - Final sync queue size:', this.syncQueue.length);
        
        // Log final sync queue state
        console.log('üìã Final sync queue after assignment creation:');
        this.syncQueue.forEach((item, index) => {
          console.log(`  ${index + 1}. ${item.collection}/${item.action} - ID: ${item.id} - Age: ${Math.round((Date.now() - item.timestamp) / 1000)}s - Retries: ${item.retryCount}`);
        });
        
        return { id: assignmentId, syncStatus: this.isOnline ? 'synced' : 'pending' };
    } catch (error) {
      console.error('‚ùå Error adding assignment via applyOp:', error);
      throw error;
    }
  }

  // ============================================
  // LOCAL DATA HELPERS
  // ============================================

  private async getLocalProducts(): Promise<any[]> {
    // Use the unified offline-first cache system
    return await this.getLocalData('products');
  }

  private async getLocalUsers(): Promise<any[]> {
    try {
      const data = await AsyncStorage.getItem('staff-users');
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  }

  private async getLocalAssignments(): Promise<any[]> {
    try {
      const data = await AsyncStorage.getItem('assignments');
      if (!data) return [];
      
      const assignments = JSON.parse(data);
      
      // Validate and clean assignments data
      return assignments.map((assignment: any) => {
        // Ensure totalAmount/total is a valid number
        const total = assignment.totalAmount || assignment.total || 0;
        const validTotal = typeof total === 'number' && !isNaN(total) ? total : 0;
        
        return {
          ...assignment,
          totalAmount: validTotal,
          total: validTotal, // For backward compatibility
        };
      });
    } catch (error) {
      console.error('Error loading local assignments:', error);
      return [];
    }
  }

  private async updateLocalProduct(id: string, updates: any): Promise<void> {
    const products = await this.getLocalProducts();
    const index = products.findIndex(p => p.id === id);
    if (index !== -1) {
      products[index] = { ...products[index], ...updates };
      await AsyncStorage.setItem('products', JSON.stringify(products));
    }
  }

  private async removeLocalProduct(id: string): Promise<void> {
    const products = await this.getLocalProducts();
    const filtered = products.filter(p => p.id !== id);
    await AsyncStorage.setItem('products', JSON.stringify(filtered));
  }

  // ============================================
  // PUBLIC STATUS METHODS
  // ============================================

  public getConnectionStatus(): boolean {
    // Add real-time NetInfo check for debugging
    NetInfo.fetch().then(state => {
      if (state.isConnected !== this.isOnline) {
        console.warn('üö® NetInfo vs Internal State Mismatch:', {
          netInfoConnected: state.isConnected,
          netInfoReachable: state.isInternetReachable,
          internalIsOnline: this.isOnline,
          netInfoType: state.type,
          timestamp: new Date().toLocaleTimeString()
        });
      }
    });
    
    return this.isOnline;
  }

  public getSyncQueueLength(): number {
    return this.syncQueue.length;
  }

  /**
   * Get sync queue items grouped for UI display
   * Groups related operations (same batchId) into single items
   */
  public getSyncQueueGrouped(): Array<{
    id: string;
    label: string;
    count: number;
    timestamp: number;
    collections: string[];
    batchId?: string;
  }> {
    const groups = new Map<string, {
      id: string;
      label: string;
      count: number;
      timestamp: number;
      collections: Set<string>;
      batchId?: string;
    }>();

    // Group items by batchId or treat as individual items
    this.syncQueue.forEach(item => {
      const groupKey = item.batchId || item.id;
      
      if (groups.has(groupKey)) {
        const group = groups.get(groupKey)!;
        group.count++;
        group.collections.add(item.collection);
        // Use earliest timestamp
        group.timestamp = Math.min(group.timestamp, item.timestamp);
      } else {
        groups.set(groupKey, {
          id: groupKey,
          label: item.batchLabel || `${item.action} ${item.collection}`,
          count: 1,
          timestamp: item.timestamp,
          collections: new Set([item.collection]),
          batchId: item.batchId
        });
      }
    });

    // Convert to array and format collections
    return Array.from(groups.values()).map(group => ({
      ...group,
      collections: Array.from(group.collections)
    })).sort((a, b) => a.timestamp - b.timestamp);
  }

  /**
   * Get raw sync queue for debugging
   */
  public getSyncQueueRaw(): SyncQueueItem[] {
    return [...this.syncQueue];
  }

  /**
   * Debug method: Get all product IDs from local cache
   */
  public async debugProductIds(): Promise<{localProducts: any[], syncQueueItems: any[]}> {
    const localProducts = await this.getLocalData('products');
    const relevantSyncItems = this.syncQueue.filter(item => 
      item.collection === 'products' || 
      (item.collection === 'assignments' && item.data?.productId)
    );
    
    console.log('üîç DEBUG - Local Products:', localProducts.map(p => ({id: p.id, name: p.name, stock: p.stock})));
    console.log('üîç DEBUG - Sync Queue Product Items:', relevantSyncItems.map(item => ({
      id: item.id,
      collection: item.collection,
      action: item.action,
      productId: item.data?.productId || item.data?.entityId,
      data: item.data
    })));
    
    return { localProducts, syncQueueItems: relevantSyncItems };
  }

  // Debug methods for testing offline functionality
  public forceOfflineMode(): void {
    console.log('üß™ DEBUG: Forcing offline mode');
    this.isOnline = false;
  }

  public forceOnlineMode(): void {
    console.log('üß™ DEBUG: Forcing online mode');
    this.isOnline = true;
  }

  // Force refresh network state from NetInfo
  public async refreshNetworkState(): Promise<boolean> {
    try {
      const state = await NetInfo.fetch();
      const previousState = this.isOnline;
      this.isOnline = (state.isConnected === true) && (state.isInternetReachable !== false);
      
      console.log('üîÑ Manual network state refresh:', {
        previous: previousState,
        current: this.isOnline,
        netInfoConnected: state.isConnected,
        netInfoReachable: state.isInternetReachable,
        type: state.type
      });
      
      return this.isOnline;
    } catch (error) {
      console.error('‚ùå Failed to refresh network state:', error);
      return this.isOnline;
    }
  }

  public async forcSync(): Promise<void> {
    console.log('üîÑ Manual sync requested');
    await this.processSyncQueue();
    
    // Also sync player balances as part of full sync
    try {
      console.log('üîÑ Syncing player balances...');
      await firebaseService.syncAllPlayerBalances();
      console.log('‚úÖ Player balances synced');
    } catch (error) {
      console.error('‚ùå Failed to sync player balances:', error);
      // Don't throw - sync queue was successful
    }
  }

  public async clearSyncQueue(): Promise<void> {
    const itemCount = this.syncQueue.length;
    console.log(`üßπ CLEARING entire sync queue: ${itemCount} items`);
    
    // Log what we're clearing
    this.syncQueue.forEach((item, index) => {
      console.log(`  Removing ${index + 1}. ${item.collection}/${item.action} - ID: ${item.id} - Age: ${Math.round((Date.now() - item.timestamp) / 1000)}s`);
    });
    
    this.syncQueue = [];
    await this.saveSyncQueue();
    console.log(`‚úÖ CLEARED entire sync queue: ${itemCount} items removed`);
  }

  /**
   * EMERGENCY: Clear all sync data and rebuild from scratch
   */
  public async emergencyCleanAndRebuild(): Promise<void> {
    console.log('üö® === EMERGENCY CLEAN AND REBUILD ===');
    
    // Clear sync queue
    const queueCount = this.syncQueue.length;
    this.syncQueue = [];
    await this.saveSyncQueue();
    
    // Clear dead letter queue
    this.deadLetterQueue = [];
    await this.saveDeadLetterQueue();
    
    // Clear processed IDs (if exists)
    if (this.processedIds) {
      this.processedIds.clear();
    }
    
    console.log(`‚úÖ EMERGENCY CLEAN: Removed ${queueCount} sync items, cleared all queues`);
    console.log('üö® === END EMERGENCY CLEAN ===');
  }

  /**
   * Debug method to inspect and potentially clean specific legacy items
   */
  public async inspectAndCleanLegacyItems(): Promise<void> {
    console.log('üîç === LEGACY ITEM INSPECTION ===');
    
    const now = Date.now();
    
    let removedCount = 0;
    const itemsToKeep: SyncQueueItem[] = [];
    
    for (const item of this.syncQueue) {
      const age = now - item.timestamp;
      const ageHours = Math.round(age / (60 * 60 * 1000));
      const shouldRemove = this.shouldRemoveLegacyItem(item, age);
      
      console.log(`üìã Item: ${item.collection}/${item.action} - ID: ${item.id}`);
      console.log(`   Age: ${ageHours} hours, Retries: ${item.retryCount}, Remove: ${shouldRemove}`);
      
      if (shouldRemove) {
        console.log(`   üóëÔ∏è REMOVING: ${item.collection}/${item.action} - ${item.id}`);
        removedCount++;
      } else {
        itemsToKeep.push(item);
      }
    }
    
    if (removedCount > 0) {
      this.syncQueue = itemsToKeep;
      await this.saveSyncQueue();
      console.log(`‚úÖ Removed ${removedCount} legacy items, kept ${itemsToKeep.length}`);
    } else {
      console.log('‚úÖ No legacy items found to remove');
    }
    
    console.log('üîç === END LEGACY INSPECTION ===');
  }
  
  private shouldRemoveLegacyItem(item: SyncQueueItem, age: number): boolean {
    const oneHour = 60 * 60 * 1000;
    const oneDay = 24 * 60 * 60 * 1000;
    
    // Remove items older than 1 day
    if (age > oneDay) {
      return true;
    }
    
    // Remove items older than 1 hour with high retry counts
    if (age > oneHour && item.retryCount >= 3) {
      return true;
    }
    
    // Remove items with excessive retry counts
    if (item.retryCount >= this.maxRetries) {
      return true;
    }
    
    return false;
  }

  /**
   * Debug method to check and fix product stock/quantity inconsistencies
   */
  public async fixProductStockInconsistencies(): Promise<void> {
    console.log('üîß === PRODUCT STOCK CONSISTENCY CHECK ===');
    
    try {
      const products = await this.getLocalData('products');
      let fixedCount = 0;
      
      for (const product of products) {
        const stockValue = product.stock || 0;
        const quantityValue = product.quantity || 0;
        
        console.log(`üì¶ Product: ${product.name} (${product.id})`);
        console.log(`   Stock: ${stockValue}, Quantity: ${quantityValue}, Match: ${stockValue === quantityValue}`);
        
        // If they don't match, prioritize stock field and sync both
        if (stockValue !== quantityValue) {
          console.log(`   üîß FIXING: Setting both stock and quantity to ${stockValue}`);
          
          const updateData = {
            stock: stockValue,
            quantity: stockValue,
            updatedAt: new Date().toISOString()
          };
          
          await this.updateProduct(product.id, updateData);
          fixedCount++;
        }
      }
      
      console.log(`‚úÖ Fixed ${fixedCount} product inconsistencies`);
      
    } catch (error) {
      console.error('‚ùå Error fixing product inconsistencies:', error);
    }
    
    console.log('üîß === END CONSISTENCY CHECK ===');
  }

  // ============================================
  // PUBLIC USER MANAGEMENT METHODS
  // ============================================

  public async getUsers(): Promise<string[]> {
    try {
      if (this.isOnline) {
        // Try to get from Firebase first
        const firebaseUsers = await firebaseService.getUsers();
        const userNames = firebaseUsers.map(user => {
          // Ensure consistent name format: use name field if present, otherwise combine firstName + lastName
          const fullName = `${user.firstName || ''} ${user.lastName || ''}`.trim();
          return user.name || fullName || 'Unknown User';
        });
        // Update local storage
        await AsyncStorage.setItem('staff-users', JSON.stringify(userNames));
        return userNames;
      } else {
        // Return from local storage
        const localUsers = await this.getLocalUsers();
        return Array.isArray(localUsers) && localUsers.length > 0 && typeof localUsers[0] === 'string' 
          ? localUsers 
          : localUsers.map((user: any) => typeof user === 'string' ? user : user.name || '');
      }
    } catch (error) {
      console.error('Error getting users:', error);
      return await this.getLocalUserNames();
    }
  }

  private async getLocalUserNames(): Promise<string[]> {
    try {
      const data = await AsyncStorage.getItem('staff-users');
      const users = data ? JSON.parse(data) : [];
      // Handle both string arrays and object arrays
      return Array.isArray(users) ? users.map((user: any) => typeof user === 'string' ? user : user.name || '') : [];
    } catch {
      return [];
    }
  }

  public async deleteUser(userName: string): Promise<void> {
    try {
      const currentUsers = await this.getUsers();
      const updatedUsers = currentUsers.filter(name => name !== userName);
      await AsyncStorage.setItem('staff-users', JSON.stringify(updatedUsers));
      
      // Add to sync queue if online
      if (this.isOnline) {
        this.addToSyncQueue({
          id: `delete_user_${userName}_${Date.now()}`,
          action: 'delete',
          collection: 'staff-users',
          data: { name: userName }
        });
      }
    } catch (error) {
      console.error('Error deleting user:', error);
      throw error;
    }
  }

  // ============================================
  // PUBLIC ASSIGNMENT MANAGEMENT METHODS
  // ============================================

  public async getAssignments(): Promise<any[]> {
    console.log('üìñ Reading assignments from local cache (single source of truth)');
    const localAssignments = await this.getLocalData('assignments');
    
    // Check if this is first-time access or cache needs refresh
    const isFirstTimeOrStale = await this.isFirstTimeOrStaleCache('assignments');
    
    if ((localAssignments.length === 0 || isFirstTimeOrStale) && this.isOnline) {
      console.log('üì¶ First-time access or stale cache - doing initial assignments sync');
      try {
        const fbService = new FirebaseService();
        const serverAssignments = await fbService.getAssignments();
        
        await this.markCacheInitialized('assignments');
        await this.saveLocalData('assignments', serverAssignments);
        
        console.log('‚úÖ Initial assignments sync completed:', serverAssignments.length);
        
        // Start background hydration
        this.hydrateAssignmentsFromServer().catch(error => {
          console.warn('‚ö†Ô∏è Background assignment hydration failed:', error);
        });
        
        return serverAssignments;
      } catch (error) {
        console.error('‚ùå Initial assignments sync failed:', error);
        return localAssignments;
      }
    } else if ((localAssignments.length === 0 || isFirstTimeOrStale) && !this.isOnline) {
      console.log('üì± Offline first-time access - no assignments available');
      return [];
    }
    
    // Cache has data - do background hydration as normal
    if (this.isOnline) {
      this.hydrateAssignmentsFromServer().catch(error => {
        console.warn('‚ö†Ô∏è Background assignment hydration failed:', error);
      });
    }
    
    console.log('‚úÖ Returning local assignments:', localAssignments.length);
    return localAssignments;
  }

  /**
   * Background hydration from server - applies server updates via applyOp
   */
  private async hydrateAssignmentsFromServer(): Promise<void> {
    try {
      console.log('üîÑ Background: Hydrating assignments from server');
      const serverAssignments = await firebaseService.getAssignments();
      
      // Apply each server update via applyOp for consistency
      for (const serverAssignment of serverAssignments) {
        // Properly handle Firebase Timestamp objects
        let timestamp: number;
        try {
          console.log('üîç Debug: serverAssignment.updatedAt:', serverAssignment.updatedAt, 'type:', typeof serverAssignment.updatedAt);
          
          if (serverAssignment.updatedAt?.seconds) {
            // Firebase Timestamp object - convert seconds to milliseconds
            timestamp = serverAssignment.updatedAt.seconds * 1000;
            // Add nanoseconds if available
            if (serverAssignment.updatedAt.nanoseconds) {
              timestamp += Math.floor(serverAssignment.updatedAt.nanoseconds / 1000000);
            }
            console.log('üîç Converted Firebase Timestamp:', timestamp);
          } else if (serverAssignment.updatedAt?.toDate) {
            // Firebase Timestamp with toDate method
            timestamp = serverAssignment.updatedAt.toDate().getTime();
            console.log('üîç Converted via toDate():', timestamp);
          } else if (typeof serverAssignment.updatedAt === 'string') {
            // ISO string - validate and convert to milliseconds
            const dateTest = new Date(serverAssignment.updatedAt);
            if (isNaN(dateTest.getTime())) {
              throw new Error(`Invalid ISO string: ${serverAssignment.updatedAt}`);
            }
            timestamp = dateTest.getTime();
            console.log('üîç Converted ISO string:', serverAssignment.updatedAt, '‚Üí', timestamp);
          } else if (typeof serverAssignment.updatedAt === 'number') {
            // Already milliseconds
            timestamp = serverAssignment.updatedAt;
            console.log('üîç Already number:', timestamp);
          } else {
            // Fallback to current time
            timestamp = Date.now();
            console.warn('‚ö†Ô∏è Could not parse updatedAt timestamp, using current time:', serverAssignment.updatedAt);
          }
          
          // Validate timestamp is reasonable (not too far in future or past)
          const now = Date.now();
          const oneYearMs = 365 * 24 * 60 * 60 * 1000;
          if (timestamp < now - oneYearMs || timestamp > now + oneYearMs) {
            console.warn('‚ö†Ô∏è Timestamp seems unreasonable, using current time:', new Date(timestamp));
            timestamp = now;
          }
          
        } catch (error) {
          console.warn('‚ö†Ô∏è Error processing timestamp, using current time:', error, 'Original:', serverAssignment.updatedAt);
          timestamp = Date.now();
        }

        const operation: Operation = {
          id: generateUUID(),
          type: 'update',
          collection: 'assignments',
          entityId: serverAssignment.id,
          data: serverAssignment,
          metadata: {
            deviceId: 'server',
            timestamp: timestamp,
            version: 0, // Server doesn't have vector clocks yet
            vectorClock: {},
            source: 'server'
          }
        };
        
        // Apply server updates via single write path
        await this.applyOp(operation);
      }
      
      console.log('‚úÖ Server assignment hydration completed via applyOp');
      
    } catch (error) {
      console.error('‚ùå Server assignment hydration failed:', error);
    }
  }

  // Merge assignments, preserving local changes like payment status
  private mergeAssignments(serverAssignments: any[], localAssignments: any[]): any[] {
    const merged = [...serverAssignments];
    
    // For each local assignment, check if it has changes that should be preserved
    localAssignments.forEach(localAssignment => {
      const serverIndex = merged.findIndex(s => s.id === localAssignment.id);
      
      if (serverIndex !== -1) {
        const serverAssignment = merged[serverIndex];
        const localUpdatedAt = new Date(localAssignment.updatedAt || 0).getTime();
        const serverUpdatedAt = new Date(serverAssignment.updatedAt?.seconds ? 
          serverAssignment.updatedAt.seconds * 1000 : 
          serverAssignment.updatedAt || 0).getTime();
        
        // If local version is newer or has payment status changes, preserve those
        if (localUpdatedAt > serverUpdatedAt || 
            (localAssignment.paid !== undefined && localAssignment.paid !== serverAssignment.paid)) {
          
          console.log(`üîÑ Preserving local changes for assignment ${localAssignment.id}:`, {
            localPaid: localAssignment.paid,
            serverPaid: serverAssignment.paid,
            localUpdated: new Date(localUpdatedAt).toLocaleString(),
            serverUpdated: new Date(serverUpdatedAt).toLocaleString()
          });
          
          // Merge, preferring local changes for critical fields
          merged[serverIndex] = {
            ...serverAssignment,
            ...localAssignment,
            // Preserve local payment status and other user-modified fields
            paid: localAssignment.paid !== undefined ? localAssignment.paid : serverAssignment.paid,
            updatedAt: Math.max(localUpdatedAt, serverUpdatedAt)
          };
        }
      }
    });
    
    return merged;
  }

  public async updateAssignment(assignmentId: string, updates: any): Promise<void> {
    // ALL writes go through applyOp - single source of truth
    const operation: Operation = {
      id: generateUUID(),
      type: 'update',
      collection: 'assignments',
      entityId: assignmentId,
      data: updates,
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    console.log('ÔøΩ Assignment update via applyOp:', {
      assignmentId,
      updates,
      paid: updates.paid,
      operationId: operation.id
    });

    await this.applyOp(operation);
  }

  public async updateMultipleAssignments(userName: string, updates: any): Promise<void> {
    try {
      const assignments = await this.getAssignments();
      // Handle both old format (user), new format (playerName), and Firebase format (userName)
      const userAssignments = assignments.filter((a: any) => {
        const assignmentUser = a.playerName || a.userName || a.user; // Try all formats
        return assignmentUser === userName && !a.paid;
      });
      
      for (const assignment of userAssignments) {
        await this.updateAssignment(assignment.id, updates);
      }
    } catch (error) {
      console.error('Error updating multiple assignments:', error);
      throw error;
    }
  }

  public async deleteAssignment(assignmentId: string): Promise<void> {
    try {
      // Offline-first: Remove from local storage immediately
      const localAssignments = await this.getLocalAssignments();
      const updatedAssignments = localAssignments.filter(a => a.id !== assignmentId);
      await AsyncStorage.setItem('assignments', JSON.stringify(updatedAssignments));

      // If online, delete from Firebase
      if (this.isOnline) {
        try {
          await firebaseService.deleteAssignment(assignmentId);
          console.log('‚úÖ Assignment deleted from Firebase:', assignmentId);
        } catch (error) {
          console.warn('‚ö†Ô∏è Failed to delete from Firebase, will sync when online:', error);
          // Add to sync queue for later
          this.addToSyncQueue({
            id: assignmentId,
            action: 'delete',
            collection: 'assignments',
            data: { id: assignmentId, deleted: true }
          });
        }
      } else {
        // Add to sync queue for when we come back online
        this.addToSyncQueue({
          id: assignmentId,
          action: 'delete',
          collection: 'assignments',
          data: { id: assignmentId, deleted: true }
        });
      }

      console.log('‚úÖ Assignment deleted (offline-first):', assignmentId);
    } catch (error) {
      console.error('Error deleting assignment:', error);
      throw error;
    }
  }

  // ============================================
  // PUBLIC PRODUCT MANAGEMENT METHODS
  // ============================================

  public async getProducts(): Promise<any[]> {
    console.log('üì¶ Reading products from local cache (single source of truth)');
    
    try {
      // ALWAYS read from the unified offline-first cache first
      const localProducts = await this.getLocalData('products');
      
      // If we have local data, return it immediately (offline-first principle)
      if (localProducts && localProducts.length > 0) {
        console.log(`‚úÖ Returning local products: ${localProducts.length}`);
        
        // Background sync if online (don't wait)
        if (this.isOnline) {
          console.log('üîÑ Background: Hydrating products from server');
          this.hydrateProductsFromServer().catch((error: any) => {
            console.warn('Background product sync failed:', error);
          });
        }
        
        return localProducts;
      }
      
      // No local data - try initial sync if online
      if (this.isOnline) {
        console.log('üì¶ First-time access or stale cache - doing initial products sync');
        return await this.doInitialProductsSync();
      }
      
      // Offline with no cache - return empty array
      console.log('‚ö†Ô∏è Offline with no cached products');
      return [];
      
    } catch (error) {
      console.error('‚ùå Error getting products:', error);
      return [];
    }
  }



  // ============================================
  // SYNC STATUS & MONITORING
  // ============================================



  public async forceSyncNow(): Promise<void> {
    console.log('üöÄ Manual sync triggered');
    if (!this.isOnline) {
      throw new Error('Cannot sync while offline');
    }
    
    // Reset all timestamps to allow immediate retry
    this.syncQueue.forEach(item => {
      item.timestamp = Date.now();
    });
    
    await this.saveSyncQueue();
    return this.processSyncQueue();
  }

  // ============================================
  // CACHE INITIALIZATION HELPERS
  // ============================================

  /**
   * Check if this is first-time access or cache needs refresh
   */
  private async isFirstTimeOrStaleCache(collection: string): Promise<boolean> {
    try {
      const cacheKey = `cache_initialized_${collection}_${this.getCurrentUserKey()}`;
      const initialized = await AsyncStorage.getItem(cacheKey);
      const lastSync = await AsyncStorage.getItem(`last_sync_${collection}`);
      
      // Not initialized OR last sync was more than 1 hour ago
      const oneHourAgo = Date.now() - (60 * 60 * 1000);
      const isStale = lastSync ? parseInt(lastSync) < oneHourAgo : true;
      
      return !initialized || isStale;
    } catch (error) {
      console.warn('Cache initialization check failed:', error);
      return true; // Assume first-time if check fails
    }
  }

  /**
   * Mark cache as initialized for current user/organization
   */
  private async markCacheInitialized(collection: string): Promise<void> {
    try {
      const cacheKey = `cache_initialized_${collection}_${this.getCurrentUserKey()}`;
      const syncKey = `last_sync_${collection}`;
      
      await AsyncStorage.setItem(cacheKey, 'true');
      await AsyncStorage.setItem(syncKey, Date.now().toString());
    } catch (error) {
      console.warn('Failed to mark cache as initialized:', error);
    }
  }

  /**
   * Get unique key for current user/organization combination
   * Critical for multi-device scenarios with same account
   */
  private getCurrentUserKey(): string {
    // TODO: Replace with actual user authentication context
    // Should be: `${userId}_${organizationId}` for proper isolation
    // For now using device ID, but this needs user context from auth system
    return this.deviceId;
  }

  /**
   * Handle distributed user scenario - same account on multiple devices
   * This is where vector clocks become critical for conflict resolution
   */
  public async handleDistributedUserConflicts(): Promise<void> {
    console.log('‚ö° Checking for distributed user conflicts (same account, different devices)');
    
    if (!this.isOnline) {
      console.log('üì± Offline - conflicts will be resolved when back online');
      return;
    }
    
    try {
      // Get latest server state for comparison
      const fbService = new FirebaseService();
      const [serverPlayers, serverAssignments] = await Promise.all([
        fbService.getPlayers(),
        fbService.getAssignments()
      ]);
      
      // Check for conflicts using vector clocks and timestamps
      await this.detectAndResolveConflicts('players', serverPlayers);
      await this.detectAndResolveConflicts('assignments', serverAssignments);
      
      console.log('‚úÖ Distributed conflict resolution completed');
    } catch (error) {
      console.warn('‚ö†Ô∏è Distributed conflict resolution failed:', error);
    }
  }

  /**
   * Detect and resolve conflicts between local and server data
   */
  private async detectAndResolveConflicts(collection: string, serverData: any[]): Promise<void> {
    const localData = await this.getLocalData(collection);
    
    for (const serverItem of serverData) {
      const localItem = localData.find(item => item.id === serverItem.id);
      
      if (localItem && this.hasConflict(localItem, serverItem)) {
        console.log(`üîÑ Resolving conflict for ${collection}:${serverItem.id}`);
        
        // Apply server update through applyOp for consistent handling
        await this.applyOp({
          id: generateUUID(),
          type: 'update',
          collection: collection as any,
          entityId: serverItem.id,
          data: serverItem,
          metadata: {
            deviceId: 'server',
            timestamp: Date.now(),
            version: serverItem.version || 1,
            vectorClock: serverItem.vectorClock || {},
            source: 'server'
          }
        });
      }
    }
  }

  /**
   * Check if there's a conflict between local and server versions
   */
  private hasConflict(localItem: any, serverItem: any): boolean {
    // Simple timestamp-based conflict detection
    // In production, would use vector clocks for proper causal ordering
    const localTimestamp = localItem.updatedAt || 0;
    const serverTimestamp = serverItem.updatedAt || 0;
    
    return Math.abs(localTimestamp - serverTimestamp) > 1000; // 1 second tolerance
  }

  /**
   * SAFELY clear cached data only after ensuring all data is synced to server
   * This prevents data loss during user switches or logouts
   */
  public async safelyLogoutUser(): Promise<void> {
    console.log('üîê Starting safe user logout process');
    
    try {
      // Step 1: Force sync all pending operations
      if (this.syncQueue.length > 0) {
        console.log(`üì§ Syncing ${this.syncQueue.length} pending operations before logout`);
        await this.forceSyncNow();
        
        // Wait a bit more to ensure sync completed
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Check if sync queue is now empty
        if (this.syncQueue.length > 0) {
          throw new Error(`Cannot logout safely - ${this.syncQueue.length} operations still pending sync`);
        }
      }
      
      // Step 2: Do final server sync to ensure everything is persisted
      if (this.isOnline) {
        console.log('üîÑ Final verification sync before logout');
        await this.verifyAllDataSynced();
      } else {
        throw new Error('Cannot logout safely while offline - pending changes may be lost');
      }
      
      // Step 3: Only now is it safe to clear cache
      await this.clearCacheAfterSync();
      
      console.log('‚úÖ Safe logout completed - all data preserved');
    } catch (error) {
      console.error('‚ùå Safe logout failed:', error);
      throw new Error(`Logout blocked to prevent data loss: ${error instanceof Error ? error.message : error}`);
    }
  }

  /**
   * Internal method to clear cache only after sync verification
   */
  private async clearCacheAfterSync(): Promise<void> {
    const collections = ['players', 'assignments', 'products', 'staff-users', 'reports'];
    const currentUserKey = this.getCurrentUserKey();
    
    // Clear all collection data (using actual storage keys, not _data suffix)
    for (const collection of collections) {
      await AsyncStorage.removeItem(collection); // Remove actual data
      await AsyncStorage.removeItem(`cache_initialized_${collection}_${currentUserKey}`);
      await AsyncStorage.removeItem(`last_sync_${collection}`);
    }
    
    // Clear sync queue and processed IDs
    await AsyncStorage.removeItem('syncQueue');
    this.syncQueue = [];
    this.processedIds.clear();
  }

  /**
   * Verify all local changes have been persisted to server
   */
  private async verifyAllDataSynced(): Promise<void> {
    // This would ideally check server timestamps vs local timestamps
    // For now, we ensure sync queue is empty and do a final push
    if (this.syncQueue.length > 0) {
      throw new Error('Sync queue not empty');
    }
    
    // Could add additional verification by comparing local vs server data
    console.log('‚úÖ All data verified as synced to server');
  }

  /**
   * EMERGENCY logout - clears cache even with unsaved changes
   * ‚ö†Ô∏è WARNING: This WILL cause data loss if there are pending changes
   * Only use when user explicitly accepts data loss risk
   */
  public async emergencyLogout(userConfirmsDataLoss: boolean = false): Promise<void> {
    if (!userConfirmsDataLoss) {
      throw new Error('Emergency logout requires explicit user confirmation of data loss risk');
    }

    console.warn('üö® EMERGENCY LOGOUT - Data loss may occur!');
    console.warn(`‚ö†Ô∏è Losing ${this.syncQueue.length} pending operations`);
    
    // Clear everything regardless of sync status
    await this.clearCacheAfterSync();
    
    console.warn('üö® Emergency logout completed - some data may have been lost');
  }

  // ============================================
  // PLAYER OPERATIONS
  // ============================================

  public async getPlayers(): Promise<any[]> {
    // ALWAYS read local cache first (local is truth)
    console.log('ÔøΩ Reading players from local cache (single source of truth)');
    const localPlayers = await this.getLocalData('players'); // Players are stored as players
    
    // If online, hydrate from server in background (don't block UI)
    if (this.isOnline) {
      this.hydratePlayersFromServer().catch(error => {
        console.warn('‚ö†Ô∏è Background server hydration failed:', error);
      });
    }
    
    // Check if this is first-time access or cache needs refresh
    const isFirstTimeOrStale = await this.isFirstTimeOrStaleCache('players'); // Players cache key
    
    // ALWAYS sync from server when online to ensure we have all players (like products do)
    if (this.isOnline) {
      console.log('üì¶ Syncing with server and merging with local changes');
      try {
        const fbService = new FirebaseService();
        const serverPlayers = await fbService.getPlayers();
        
        // Merge server players with local-only players (that haven't synced yet)
        console.log('üîç Before merge - Local players:', localPlayers.length, 'Server players:', serverPlayers.length);
        const mergedPlayers = await this.mergeServerWithLocalPlayers(serverPlayers, localPlayers);
        
        // RACE CONDITION FIX: Atomic save to prevent UI flicker
        console.log('üíæ Saving merged players atomically...');
        await this.markCacheInitialized('players');
        
        // Ensure merged data is valid before saving
        if (!Array.isArray(mergedPlayers) || mergedPlayers.length === 0) {
          console.warn('‚ö†Ô∏è Merged data is invalid, keeping existing local data');
          return localPlayers; // Return original local data if merge failed
        }
        
        await this.saveLocalData('players', mergedPlayers); // Store merged data
        
        // Verify what we actually saved
        const savedPlayers = await this.getLocalPlayers();
        console.log('üîç After save - Cached players:', savedPlayers.length);
        
        console.log('‚úÖ Server sync completed:', serverPlayers.length, 'server +', mergedPlayers.length - serverPlayers.length, 'local = ', mergedPlayers.length, 'total');
        return mergedPlayers;
      } catch (error) {
        console.error('‚ùå Initial server sync failed:', error);
        return localPlayers; // Return local cache even if empty
      }
    } else if (!this.isOnline) {
      console.log('üì± Offline: returning local cache');
      return localPlayers;
    }
    
    console.log('‚úÖ Returning local players:', localPlayers.length);
    return localPlayers;
  }

  /**
   * Background hydration from server - applies server updates via applyOp
   */
  private async hydratePlayersFromServer(): Promise<void> {
    try {
      console.log('üîÑ Background: Hydrating players from server');
      const fbService = new FirebaseService();
      const serverPlayers = await fbService.getPlayers();
      
      // Apply each server update via applyOp for consistency
      for (const serverPlayer of serverPlayers) {
        // Properly handle Firebase Timestamp objects (same logic as assignments)
        let timestamp: number;
        try {
          console.log('üîç Debug: serverPlayer.updatedAt:', serverPlayer.updatedAt, 'type:', typeof serverPlayer.updatedAt);
          
          if (serverPlayer.updatedAt?.seconds) {
            // Firebase Timestamp object - convert seconds to milliseconds
            timestamp = serverPlayer.updatedAt.seconds * 1000;
            // Add nanoseconds if available
            if (serverPlayer.updatedAt.nanoseconds) {
              timestamp += Math.floor(serverPlayer.updatedAt.nanoseconds / 1000000);
            }
            console.log('üîç Converted Firebase Timestamp:', timestamp);
          } else if (serverPlayer.updatedAt?.toDate) {
            // Firebase Timestamp with toDate method
            timestamp = serverPlayer.updatedAt.toDate().getTime();
            console.log('üîç Converted via toDate():', timestamp);
          } else if (typeof serverPlayer.updatedAt === 'string') {
            // ISO string - validate and convert to milliseconds
            const dateTest = new Date(serverPlayer.updatedAt);
            if (isNaN(dateTest.getTime())) {
              throw new Error(`Invalid ISO string: ${serverPlayer.updatedAt}`);
            }
            timestamp = dateTest.getTime();
            console.log('üîç Converted ISO string:', serverPlayer.updatedAt, '‚Üí', timestamp);
          } else if (typeof serverPlayer.updatedAt === 'number') {
            // Already milliseconds
            timestamp = serverPlayer.updatedAt;
            console.log('üîç Already number:', timestamp);
          } else {
            // Fallback to current time
            timestamp = Date.now();
            console.warn('‚ö†Ô∏è Could not parse updatedAt timestamp, using current time:', serverPlayer.updatedAt);
          }
          
          // Validate timestamp is reasonable (not too far in future or past)
          const now = Date.now();
          const oneYearMs = 365 * 24 * 60 * 60 * 1000;
          if (timestamp < now - oneYearMs || timestamp > now + oneYearMs) {
            console.warn('‚ö†Ô∏è Timestamp seems unreasonable, using current time:', new Date(timestamp));
            timestamp = now;
          }
          
        } catch (error) {
          console.warn('‚ö†Ô∏è Error processing timestamp, using current time:', error, 'Original:', serverPlayer.updatedAt);
          timestamp = Date.now();
        }

        const operation: Operation = {
          id: generateUUID(),
          type: 'update',
          collection: 'players', // Players stored in players collection
          entityId: serverPlayer.id,
          data: serverPlayer,
          metadata: {
            deviceId: 'server',
            timestamp: timestamp,
            version: 0, // Server doesn't have vector clocks yet
            vectorClock: {},
            source: 'server'
          }
        };
        
        // Apply server updates via single write path
        await this.applyOp(operation);
      }
      
      console.log('‚úÖ Server hydration completed via applyOp');
      
    } catch (error) {
      console.error('‚ùå Server hydration failed:', error);
    }
  }

  /**
   * Background hydration of products from server (similar to players)
   */
  private async hydrateProductsFromServer(): Promise<void> {
    try {
      console.log('üì¶ Syncing with server and merging with local changes');
      const serverProducts = await firebaseService.getProducts();
      
      if (!serverProducts || serverProducts.length === 0) {
        console.log('‚úÖ Server product hydration completed via applyOp');
        return;
      }

      // Apply each server product via applyOp
      for (const serverProduct of serverProducts) {
        // Process timestamp (same logic as players)
        let timestamp: number;
        try {
          if (serverProduct.updatedAt?.seconds) {
            timestamp = serverProduct.updatedAt.seconds * 1000 + (serverProduct.updatedAt.nanoseconds || 0) / 1000000;
            console.log('üîç Converted Firebase Timestamp:', timestamp);
          } else if (typeof serverProduct.updatedAt === 'string') {
            timestamp = new Date(serverProduct.updatedAt).getTime();
          } else if (typeof serverProduct.updatedAt === 'number') {
            timestamp = serverProduct.updatedAt;
          } else {
            timestamp = Date.now();
            console.warn('‚ö†Ô∏è No valid updatedAt timestamp, using current time');
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error processing product timestamp:', error);
          timestamp = Date.now();
        }

        const operation: Operation = {
          id: generateUUID(),
          type: 'update',
          collection: 'products',
          entityId: serverProduct.id,
          data: serverProduct,
          metadata: {
            deviceId: 'server',
            timestamp: timestamp,
            version: 0,
            vectorClock: {},
            source: 'server'
          }
        };

        await this.applyOp(operation);
      }

      console.log('‚úÖ Server product hydration completed via applyOp');
    } catch (error) {
      console.error('‚ùå Product server hydration failed:', error);
    }
  }

  /**
   * Initial products sync for first-time access
   */
  private async doInitialProductsSync(): Promise<any[]> {
    try {
      console.log('üì¶ First-time access or stale cache - doing initial products sync');
      const serverProducts = await firebaseService.getProducts();
      
      // Save to local cache using proper offline-first system
      await this.saveLocalData('products', serverProducts || []);
      console.log(`‚úÖ Initial products sync completed: ${(serverProducts || []).length}`);
      
      // Start background hydration via applyOp
      if (serverProducts && serverProducts.length > 0) {
        console.log('üîÑ Background: Hydrating products from server');
        this.hydrateProductsFromServer().catch((error: any) => {
          console.warn('Background product hydration failed:', error);
        });
      }
      
      return serverProducts || [];
    } catch (error) {
      console.error('‚ùå Initial products sync failed:', error);
      return [];
    }
  }

  private async getLocalPlayers(): Promise<any[]> {
    try {
      const data = await AsyncStorage.getItem('players'); // Players stored in players collection
      return data ? JSON.parse(data) : [];
    } catch (error) {
      console.error('‚ùå Error getting local players:', error);
      return [];
    }
  }

  public async updatePlayerBalance(playerId: string, amount: number, isDebit: boolean): Promise<void> {
    // ALL writes go through applyOp - single source of truth
    const operation: Operation = {
      id: generateUUID(),
      type: 'updateBalance',
      collection: 'players', // Players stored in players collection
      entityId: playerId,
      data: { amount, isDebit },
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    console.log('ÔøΩ Player balance update via applyOp:', {
      playerId,
      amount,
      isDebit,
      operationId: operation.id
    });

    await this.applyOp(operation);
  }

  private async updateLocalPlayerBalance(playerId: string, amount: number, isDebit: boolean): Promise<void> {
    try {
      const players = await this.getLocalPlayers();
      const timestamp = Date.now();
      const updatedPlayers = this.updatePlayerInArray(players, playerId, amount, isDebit, timestamp);
      await AsyncStorage.setItem('players', JSON.stringify(updatedPlayers)); // Players stored in players collection
      
      console.log('üíæ Updated local player balance with timestamp:', {
        playerId,
        amount,
        isDebit,
        timestamp: new Date(timestamp).toISOString()
      });
    } catch (error) {
      console.error('‚ùå Error updating local player balance:', error);
      throw error;
    }
  }

  /**
   * Pure function to update player balance in array with proper timestamps
   */
  private updatePlayerInArray(players: any[], playerId: string, amount: number, isDebit: boolean, timestamp: number): any[] {
    const playerIndex = players.findIndex(p => p.id === playerId);
    
    if (playerIndex === -1) {
      console.error('‚ùå Player not found in array:', playerId);
      return players;
    }

    const updatedPlayers = [...players];
    const player = { ...updatedPlayers[playerIndex] };
    
    // Update balance
    const currentBalance = player.balance || 0;
    player.balance = isDebit ? 
      currentBalance + amount : 
      Math.max(0, currentBalance - amount);
    
    // Update tracking fields
    if (isDebit) {
      player.totalSpent = (player.totalSpent || 0) + amount;
      player.totalPurchases = (player.totalPurchases || 0) + 1;
    }
    
    // Set timestamp and vector clock for conflict resolution
    player.updatedAt = timestamp;
    player.version = this.createVersionVector();
    
    updatedPlayers[playerIndex] = player;
    
    console.log('üîÑ Player updated in array:', {
      playerId,
      newBalance: player.balance,
      updatedAt: new Date(timestamp).toISOString(),
      isDebit,
      amount
    });
    
    return updatedPlayers;
  }

  /**
   * Merge local and server players with timestamp-based conflict resolution
   */
  private mergePlayers(localPlayers: any[], serverPlayers: any[]): any[] {
    console.log('üîÄ Starting players merge:', {
      localCount: localPlayers.length,
      serverCount: serverPlayers.length
    });

    // Start with server players as base
    const merged = [...serverPlayers];
    
    // Merge local changes
    localPlayers.forEach(localPlayer => {
      const serverIndex = merged.findIndex(p => p.id === localPlayer.id);
      
      if (serverIndex !== -1) {
        const serverPlayer = merged[serverIndex];
        const localUpdatedAt = new Date(localPlayer.updatedAt || 0).getTime();
        const serverUpdatedAt = new Date(serverPlayer.updatedAt?.seconds ? 
          serverPlayer.updatedAt.seconds * 1000 : 
          serverPlayer.updatedAt || 0).getTime();
        
        // Enhanced conflict resolution with vector clocks
        const shouldPreserveLocal = this.shouldPreserveLocalVersion(
          localPlayer, 
          serverPlayer, 
          localUpdatedAt, 
          serverUpdatedAt
        );
        
        if (shouldPreserveLocal) {
          
          console.log(`üîÑ Preserving local changes for player ${localPlayer.id}:`, {
            localBalance: localPlayer.balance,
            serverBalance: serverPlayer.balance,
            localUpdated: new Date(localUpdatedAt).toLocaleString(),
            serverUpdated: new Date(serverUpdatedAt).toLocaleString()
          });
          
          // Merge, preferring local changes for critical fields
          merged[serverIndex] = {
            ...serverPlayer,
            ...localPlayer,
            // Preserve local balance and tracking data
            balance: localPlayer.balance !== undefined ? localPlayer.balance : serverPlayer.balance,
            totalSpent: localPlayer.totalSpent !== undefined ? localPlayer.totalSpent : serverPlayer.totalSpent,
            totalPurchases: localPlayer.totalPurchases !== undefined ? localPlayer.totalPurchases : serverPlayer.totalPurchases,
            updatedAt: localUpdatedAt > serverUpdatedAt ? localPlayer.updatedAt : serverPlayer.updatedAt
          };
        }
      } else {
        // Local player not found on server, add it (rare case)
        console.log(`‚ûï Adding local-only player to merge: ${localPlayer.id}`);
        merged.push(localPlayer);
      }
    });
    
    console.log('‚úÖ Players merge completed:', {
      mergedCount: merged.length
    });
    
    return merged;
  }

  /**
   * Determine if local version should be preserved using vector clock analysis
   */
  private shouldPreserveLocalVersion(
    localEntity: any, 
    serverEntity: any, 
    localTimestamp: number, 
    serverTimestamp: number
  ): boolean {
    // Basic timestamp check
    if (localTimestamp > serverTimestamp) {
      console.log('üïê Local version newer by timestamp');
      return true;
    }
    
    // Check for critical field changes (like balance for players)
    if (localEntity.balance !== undefined && localEntity.balance !== serverEntity.balance) {
      console.log('üí∞ Local balance differs from server');
      return true;
    }
    
    // Vector clock comparison (if available)
    if (localEntity.version && serverEntity.version) {
      const localVersion = localEntity.version;
      const serverVersion = serverEntity.version;
      
      // If from same device, use version number
      if (localVersion.deviceId === serverVersion.deviceId) {
        const result = localVersion.version > serverVersion.version;
        console.log('üì± Same device version comparison:', {
          local: localVersion.version,
          server: serverVersion.version,
          preserveLocal: result
        });
        return result;
      }
      
      // Different devices - check for concurrent updates
      const isConcurrent = this.isConcurrentUpdate(localVersion, serverVersion);
      if (isConcurrent) {
        console.log('‚ö° Concurrent update detected - using timestamp fallback');
        return localTimestamp >= serverTimestamp; // Tie-breaker
      }
    }
    
    return false;
  }

  /**
   * Check if two versions represent concurrent updates
   */
  private isConcurrentUpdate(version1: any, version2: any): boolean {
    if (!version1.vectorClock || !version2.vectorClock) {
      return false;
    }
    
    // Two updates are concurrent if neither vector clock dominates the other
    let v1DominatesV2 = true;
    let v2DominatesV1 = true;
    
    const allDevices = new Set([
      ...Object.keys(version1.vectorClock),
      ...Object.keys(version2.vectorClock)
    ]);
    
    for (const deviceId of allDevices) {
      const v1Count = version1.vectorClock[deviceId] || 0;
      const v2Count = version2.vectorClock[deviceId] || 0;
      
      if (v1Count < v2Count) v1DominatesV2 = false;
      if (v2Count < v1Count) v2DominatesV1 = false;
    }
    
    // Concurrent if neither dominates
    return !v1DominatesV2 && !v2DominatesV1;
  }

  // ============================================
  // OUTBOX MANAGEMENT HELPERS
  // ============================================

  /**
   * Check if queue contains high priority items (payments, assignments)
   */
  private hasHighPriorityItems(): boolean {
    return this.syncQueue.some(item => 
      (item.collection === 'assignments' && (item.data.paid !== undefined || item.action === 'updateBalance')) ||
      item.collection === 'players' && item.action === 'updateBalance' // Players stored in players collection
    );
  }

  /**
   * Clean up processed IDs to prevent memory bloat
   */
  private cleanupProcessedIds(): void {
    // Keep only recent processed IDs (last hour)
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    
    // Note: In a production system, you'd want to store timestamps with processed IDs
    // For now, we'll just limit the size
    if (this.processedIds.size > 1000) {
      // Convert to array, keep newest 500
      const idsArray = Array.from(this.processedIds);
      this.processedIds.clear();
      
      // Keep the last 500 IDs
      idsArray.slice(-500).forEach(id => this.processedIds.add(id));
      
      console.log('üßπ Cleaned up processed IDs cache, kept 500 most recent');
    }
  }

  /**
   * Process dead letter queue - retry items that might work now
   */
  private async processDeadLetterQueue(): Promise<void> {
    if (this.deadLetterQueue.length === 0) return;
    
    console.log(`üíÄ Processing dead letter queue: ${this.deadLetterQueue.length} items`);
    
    const itemsToRetry: SyncQueueItem[] = [];
    
    // Check which items might be worth retrying
    this.deadLetterQueue.forEach(item => {
      // Retry items older than 1 hour
      if (Date.now() - item.timestamp > 3600000) {
        // Reset retry count and add back to main queue
        item.retryCount = 0;
        item.timestamp = Date.now();
        itemsToRetry.push(item);
      }
    });
    
    if (itemsToRetry.length > 0) {
      // Move items back to main queue
      this.syncQueue.push(...itemsToRetry);
      
      // Remove from dead letter queue
      this.deadLetterQueue = this.deadLetterQueue.filter(item => 
        !itemsToRetry.some(retry => retry.id === item.id)
      );
      
      await this.saveSyncQueue();
      await this.saveDeadLetterQueue();
      
      console.log(`‚ôªÔ∏è Moved ${itemsToRetry.length} items from dead letter queue back to main queue`);
    }
  }

  /**
   * Get comprehensive sync status with dead letter queue info
   */
  public getSyncStatus(): any {
    const baseStatus = {
      isOnline: this.isOnline,
      isSyncing: this.isSyncing,
      mainQueueLength: this.syncQueue.length,
      deadLetterQueueLength: this.deadLetterQueue.length,
      processedIdsCount: this.processedIds.size,
      hasHighPriority: this.hasHighPriorityItems()
    };

    if (this.syncQueue.length === 0) {
      return { ...baseStatus, status: 'idle' };
    }

    const currentTime = Date.now();
    const readyItems = this.syncQueue.filter(item => 
      item.timestamp <= currentTime && !this.processedIds.has(item.id)
    );
    const pendingItems = this.syncQueue.filter(item => 
      item.timestamp > currentTime
    );

    return {
      ...baseStatus,
      readyForSync: readyItems.length,
      pendingRetry: pendingItems.length,
      nextRetryIn: pendingItems.length > 0 ? 
        Math.max(0, Math.min(...pendingItems.map(item => item.timestamp)) - currentTime) : 0,
      averageRetryCount: this.syncQueue.length > 0 ? 
        this.syncQueue.reduce((sum, item) => sum + item.retryCount, 0) / this.syncQueue.length : 0
    };
  }

  // ============================================
  // PLAYER MANAGEMENT METHODS
  // ============================================

  /**
   * Add a new player to the players collection
   */
  async addPlayer(player: Omit<any, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    console.log('üéØ ADD PLAYER - Starting process:', {
      inputPlayer: player,
      isOnline: this.isOnline,
      timestamp: new Date().toISOString()
    });
    
    const playerId = generateUUID();
    const playerData = {
      ...player,
      id: playerId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    console.log('üéØ ADD PLAYER - Generated player data:', {
      playerId,
      playerData,
      willSyncToFirebase: this.isOnline
    });
    
    // Use applyOp for consistent data handling
    const operation: Operation = {
      id: generateUUID(),
      type: 'create',
      collection: 'players',
      entityId: playerId,
      data: playerData,
      metadata: {
        deviceId: this.deviceId,
        timestamp: Date.now(),
        version: this.incrementVectorClock(),
        vectorClock: Object.fromEntries(this.vectorClock),
        source: 'local'
      }
    };

    console.log('üéØ ADD PLAYER - Created operation:', {
      operationId: operation.id,
      operationType: operation.type,
      operationCollection: operation.collection,
      operationEntityId: operation.entityId,
      operationTimestamp: operation.metadata.timestamp,
      operationSource: operation.metadata.source
    });

    console.log('üéØ ADD PLAYER - Calling applyOp...');
    await this.applyOp(operation);
    console.log('‚úÖ ADD PLAYER - applyOp completed, player created with ID:', playerId);
    
    return playerId;
  }

  /**
   * Update a player using the unified updateEntity method
   */
  async updatePlayer(id: string, updates: Partial<any>): Promise<void> {
    console.log('üéØ HybridSyncService: Updating player:', id, updates);
    return this.updateEntity('players', id, updates);
  }

  /**
   * Delete a player by setting isActive to false
   */
  async deletePlayer(playerId: string): Promise<void> {
    console.log('üéØ HybridSyncService: Soft deleting player:', playerId);
    return this.updatePlayer(playerId, { isActive: false });
  }

  /**
   * Simple players getter - works like getProducts() for reliable offline caching
   * Use this instead of the complex getPlayers() method
   */
  public async getPlayersSimple(): Promise<any[]> {
    try {
      if (this.isOnline) {
        // Try to get from Firebase first (like products)
        console.log('üåê Online: Fetching players from Firebase (simple method)');
        const firebaseService = new FirebaseService();
        const firebasePlayers = await firebaseService.getPlayers();
        // Update local storage
        await AsyncStorage.setItem('players', JSON.stringify(firebasePlayers));
        console.log('‚úÖ Players cached to local storage:', firebasePlayers.length);
        return firebasePlayers;
      } else {
        // Return from local storage when offline
        console.log('üì± Offline: Loading players from local cache (simple method)');
        return await this.getLocalPlayers();
      }
    } catch (error) {
      console.error('‚ùå Error getting players (simple method):', error);
      // Always fallback to local cache on error
      return await this.getLocalPlayers();
    }
  }

  /**
   * Merge server players with local players that haven't synced yet
   */
  private async mergeServerWithLocalPlayers(serverPlayers: any[], localPlayers: any[]): Promise<any[]> {
    console.log('üîÑ Merging server players with local changes');
    
    // Create a map of server players by ID for fast lookup
    const serverPlayerMap = new Map();
    serverPlayers.forEach(player => {
      if (player.id) {
        serverPlayerMap.set(player.id, player);
      }
    });
    
    // Start with all server players
    const merged = [...serverPlayers];
    
    // Add local players that aren't in the server data (local-only additions)
    const localOnlyPlayers = localPlayers.filter(localPlayer => {
      // Skip if no ID
      if (!localPlayer.id) return false;
      
      // Include if not in server data (local-only player)
      return !serverPlayerMap.has(localPlayer.id);
    });
    
    // Add local-only players to the merged result
    merged.push(...localOnlyPlayers);
    
    console.log('üîÑ Merge result:', {
      server: serverPlayers.length,
      localOnly: localOnlyPlayers.length,
      total: merged.length,
      localOnlyIds: localOnlyPlayers.map(p => p.id)
    });
    
    return merged;
  }

  /**
   * Sync all player balances based on their purchase history
   */
  async syncAllPlayerBalances(): Promise<void> {
    console.log('üéØ HybridSyncService: Syncing all player balances');
    try {
      // Use the underlying FirebaseService for this complex operation
      const { FirebaseService } = require('./FirebaseService');
      const firebaseService = new FirebaseService();
      await firebaseService.syncAllPlayerBalances();
      
      // Trigger sync to refresh local data
      await this.forceSyncNow();
      
      console.log('‚úÖ All player balances synchronized');
    } catch (error) {
      console.error('‚ùå Error syncing player balances:', error);
      throw error;
    }
  }

  /**
   * Fix player name consistency across sales records
   */
  async fixPlayerNameConsistency(): Promise<void> {
    console.log('üéØ HybridSyncService: Fixing player name consistency');
    try {
      // Use the underlying FirebaseService for this complex operation
      const { FirebaseService } = require('./FirebaseService');
      const firebaseService = new FirebaseService();
      await firebaseService.fixPlayerNameConsistency();
      
      // Trigger sync to refresh local data
      await this.forceSyncNow();
      
      console.log('‚úÖ Player name consistency fixed');
    } catch (error) {
      console.error('‚ùå Error fixing player name consistency:', error);
      throw error;
    }
  }



  /**
   * Preload all critical data for offline availability
   * Call this during initial login to ensure data is cached
   */
  async preloadCriticalData(): Promise<void> {
    if (!this.isOnline) {
      console.log('‚ö†Ô∏è Offline - skipping preload, will use cached data');
      return;
    }

    console.log('üöÄ Preloading critical data for offline availability...');
    
    try {
      // Preload all critical collections in parallel
      const preloadPromises = [
        this.getPlayers(),    // Load and cache players
        this.getProducts(),   // Load and cache products  
        this.getAssignments() // Load and cache assignments
      ];
      
      const [players, products, assignments] = await Promise.all(preloadPromises);
      
      console.log('‚úÖ Critical data preloaded successfully:', {
        players: players.length,
        products: products.length, 
        assignments: assignments.length
      });
      
      // Update last sync timestamps for all collections
      const timestamp = Date.now().toString();
      await AsyncStorage.setItem('last_sync_players', timestamp);
      await AsyncStorage.setItem('last_sync_products', timestamp);
      await AsyncStorage.setItem('last_sync_assignments', timestamp);
      
    } catch (error) {
      console.error('‚ùå Error preloading critical data:', error);
      // Don't throw - partial preload is better than no preload
    }
  }

  // ============================================
  // DEBUG UTILITIES
  // ============================================
  
  /**
   * Debug current sync state - useful for troubleshooting
   */
  async debugSyncState(): Promise<void> {
    console.log('üîç =============== SYNC STATE DEBUG ===============');
    
    try {
      // Check players in local storage
      const playersStr = await AsyncStorage.getItem('players');
      const players = playersStr ? JSON.parse(playersStr) : [];
      console.log('üîç Local Storage Players:', {
        count: players.length,
        players: players.map((p: any) => ({
          id: p.id,
          name: p.name || `${p.firstName} ${p.lastName}`,
          createdAt: p.createdAt,
          hasAllFields: !!(p.firstName && p.lastName && p.id)
        }))
      });
      
      // Check sync queue
      console.log('üîç Current Sync Queue:', {
        length: this.syncQueue.length,
        items: this.syncQueue.map(item => ({
          id: item.id,
          collection: item.collection,
          action: item.action,
          timestamp: new Date(item.timestamp).toLocaleString(),
          retryCount: item.retryCount,
          entityId: item.data?.entityId || item.data?.id,
          hasData: !!item.data
        }))
      });
      
      // Check network state
      console.log('üîç Network State:', {
        isOnline: this.isOnline,
        queueLength: this.getSyncQueueLength()
      });
      
      // Check for any player operations specifically
      const playerOps = this.syncQueue.filter(item => item.collection === 'players');
      console.log('üîç Player Operations in Queue:', {
        count: playerOps.length,
        operations: playerOps
      });
      
      console.log('üîç ============================================');
      
    } catch (error) {
      console.error('‚ùå Error debugging sync state:', error);
    }
  }

  /**
   * Manual sync trigger for debugging
   */
  async debugForceSyncNow(): Promise<void> {
    console.log('üîß DEBUG: Forcing manual sync...');
    
    if (!this.isOnline) {
      console.log('‚ùå Cannot sync - currently offline');
      return;
    }
    
    if (this.syncQueue.length === 0) {
      console.log('‚ÑπÔ∏è Nothing to sync - queue is empty');
      return;
    }
    
    console.log(`üöÄ Attempting to sync ${this.syncQueue.length} items...`);
    await this.drainOutboxWithTransaction();
    console.log('‚úÖ Manual sync attempt completed');
  }

  // CLEANUP
  // ============================================

  public destroy(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }
}

// Export singleton instance
export const hybridSyncService = new HybridSyncService();